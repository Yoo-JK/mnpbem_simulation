"""
MATLAB Code Generator

Generates complete MATLAB simulation scripts with field calculation support.
"""

import numpy as np


class MatlabCodeGenerator:
    """Generates complete MATLAB simulation code."""
    
    def __init__(self, config, verbose=False):
        self.config = config
        self.verbose = verbose
    
    def generate_complete_script(self, geometry_code, material_code):
        """Generate complete MATLAB simulation script."""
        
        # Header
        header = self._generate_header()
        
        # Options
        options = self._generate_options()
        
        # Geometry (already provided)
        geometry = geometry_code
        
        # Materials (already provided)
        materials = material_code
        
        # Comparticle creation
        comparticle = self._generate_comparticle()
        
        # BEM solver
        bem_solver = self._generate_bem_solver()
        
        # Excitation
        excitation = self._generate_excitation()
        
        # Wavelength loop
        wavelength_loop = self._generate_wavelength_loop()
        
        # Save results
        save_results = self._generate_save_results()
        
        # Footer
        footer = self._generate_footer()
        
        # Combine all parts
        complete_code = f"""{header}

{options}

{geometry}

{materials}

{comparticle}

{bem_solver}

{excitation}

{wavelength_loop}

{save_results}

{footer}
"""
        return complete_code
    
    def _generate_header(self):
        """Generate script header."""
        code = """% MNPBEM Simulation Script
% Auto-generated by MNPBEM Automation Pipeline
%
% DO NOT EDIT THIS FILE MANUALLY
% Modify the configuration file instead and regenerate

clear all;
close all;
clc;

fprintf('=== MNPBEM Simulation Started ===\\n');
fprintf('Structure: %s\\n', '{structure}');
fprintf('Simulation Type: %s\\n', '{sim_type}');
""".format(
            structure=self.config['structure'],
            sim_type=self.config['simulation_type']
        )
        return code
    
    def _generate_options(self):
        """Generate BEM options."""
        sim_type = self.config['simulation_type']
        interp = self.config.get('interp', 'curv')
        waitbar = self.config.get('waitbar', 0)
        refine = self.config.get('refine', 2)
        relcutoff = self.config.get('relcutoff', 3)  # Default 3
        
        code = f"""
%% BEM Options
op = bemoptions('sim', '{sim_type}', 'interp', '{interp}', 'waitbar', {waitbar}, 'refine', {refine}, 'RelCutoff', {relcutoff});
fprintf('BEM options configured\\n');
fprintf('  - Simulation type: {sim_type}\\n');
fprintf('  - Interpolation: {interp}\\n');
fprintf('  - Refine: {refine}\\n');
fprintf('  - RelCutoff: {relcutoff}\\n');
"""
        return code
    
    def _generate_comparticle(self):
        """Generate comparticle object creation with visualization."""
        code = f"""
%% Create Comparticle Object
fprintf('\\nCreating comparticle object...\\n');
p = comparticle(epstab, particles, inout, closed, op);
fprintf('Comparticle created with %d boundary elements\\n', p.n);

%% Visualize and Save Structure
fprintf('\\nGenerating structure visualizations...\\n');

try
    % ========== 3D View with Coordinate System ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    
    % Main plot
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('3D View', 'FontSize', 14, 'FontWeight', 'bold');
    view(45, 30);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator (small axes in corner)
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver3(0, 0, 0, arrow_len, 0, 0, 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, arrow_len, 0, 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, 0, arrow_len, 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 0, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0, 0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    axis equal;
    axis off;
    view(45, 30);
    xlim([-0.3, 1.5]);
    ylim([-0.3, 1.5]);
    zlim([-0.3, 1.5]);
    
    print('structure_3D.png', '-dpng', '-r300');
    fprintf('  ✓ 3D view saved\\n');
    close(fig);
    
    % ========== XY View (Top) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    
    % Main plot
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('XY View (Top View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 90);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver(0, 0, arrow_len, 0, 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver(0, 0, 0, arrow_len, 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0.1, -0.5, 'z ⊗', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    axis equal;
    axis off;
    xlim([-0.3, 1.5]);
    ylim([-0.7, 1.5]);
    
    % Polarization indicators
    text(0.1, -1.2, 'Pol-X →', 'FontSize', 12, 'FontWeight', 'bold', 'Color', [1, 0.5, 0]);
    text(0.1, -1.5, 'Pol-Y ↑', 'FontSize', 12, 'FontWeight', 'bold', 'Color', [1, 0, 1]);
    
    print('structure_XY.png', '-dpng', '-r300');
    fprintf('  ✓ XY view saved\\n');
    close(fig);
    
    % ========== YZ View (Side) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    
    % Main plot
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    axis equal;
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('YZ View (Side View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 0);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver(0, 0, arrow_len, 0, 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver(0, 0, 0, arrow_len, 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    text(-0.5, 0.1, '⊗ x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    axis equal;
    axis off;
    xlim([-0.7, 1.5]);
    ylim([-0.3, 1.5]);
    
    % Polarization indicator
    text(0.1, -1.2, 'Pol-Y ↑', 'FontSize', 12, 'FontWeight', 'bold', 'Color', [1, 0, 1]);
    text(0.1, -1.5, 'k →', 'FontSize', 12, 'FontWeight', 'bold', 'Color', [0, 0.7, 0.7]);
    
    print('structure_YZ.png', '-dpng', '-r300');
    fprintf('  ✓ YZ view saved\\n');
    close(fig);
    
    % ========== ZX View (Front) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    
    % Main plot
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('ZX View (Front View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(90, 0);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver(0, 0, arrow_len, 0, 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver(0, 0, 0, arrow_len, 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    text(-0.5, 0.1, '⊗ y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    axis equal;
    axis off;
    xlim([-0.7, 1.5]);
    ylim([-0.3, 1.5]);
    
    % Polarization indicator
    text(0.1, -1.2, 'Pol-X →', 'FontSize', 12, 'FontWeight', 'bold', 'Color', [1, 0.5, 0]);
    text(0.1, -1.5, 'k →', 'FontSize', 12, 'FontWeight', 'bold', 'Color', [0, 0.7, 0.7]);
    
    print('structure_ZX.png', '-dpng', '-r300');
    fprintf('  ✓ ZX view saved\\n');
    close(fig);
    
    fprintf('  ✓ All structure visualizations completed!\\n');
    
catch ME
    fprintf('  Warning: Could not save structure plots: %s\\n', ME.message);
end
"""
        return code
    
    def _generate_bem_solver(self):
        """Generate BEM solver initialization."""
        code = """
%% Initialize BEM Solver
fprintf('\\nInitializing BEM solver...\\n');
bem = bemsolver(p, op);
fprintf('BEM solver initialized\\n');
"""
        return code
    
    def _generate_excitation(self):
        """Generate excitation configuration."""
        excitation_type = self.config['excitation_type']
        
        if excitation_type == 'planewave':
            code = self._generate_planewave_excitation()
        elif excitation_type == 'dipole':
            code = self._generate_dipole_excitation()
        elif excitation_type == 'eels':
            code = self._generate_eels_excitation()
        else:
            raise ValueError(f"Unknown excitation type: {excitation_type}")
        
        return code
    
    def _generate_planewave_excitation(self):
        """Generate plane wave excitation code."""
        polarizations = self.config['polarizations']
        propagation_dirs = self.config['propagation_dirs']
        
        # Convert to MATLAB arrays
        pol_str = self._python_list_to_matlab(polarizations)
        dir_str = self._python_list_to_matlab(propagation_dirs)
        
        code = f"""
%% Plane Wave Excitation
fprintf('\\nConfiguring plane wave excitation...\\n');

% Polarization vectors
pol = {pol_str};

% Propagation directions
dir = {dir_str};

fprintf('Number of polarizations: %d\\n', size(pol, 1));
fprintf('Number of propagation directions: %d\\n', size(dir, 1));
"""
        return code
    
    def _generate_dipole_excitation(self):
        """Generate dipole excitation code."""
        position = self.config.get('dipole_position', [0, 0, 15])
        moment = self.config.get('dipole_moment', [0, 0, 1])
        
        pos_str = self._python_list_to_matlab([position])
        mom_str = self._python_list_to_matlab([moment])
        
        code = f"""
%% Dipole Excitation
fprintf('\\nConfiguring dipole excitation...\\n');

% Dipole position
dip_pos = {pos_str};

% Dipole moment
dip_mom = {mom_str};

fprintf('Dipole position: [%.2f, %.2f, %.2f] nm\\n', dip_pos(1), dip_pos(2), dip_pos(3));
"""
        return code
    
    def _generate_eels_excitation(self):
        """Generate EELS excitation code."""
        impact = self.config.get('impact_parameter', [10, 0])
        energy = self.config.get('beam_energy', 200e3)
        width = self.config.get('beam_width', 0.2)
        
        code = f"""
%% EELS Excitation
fprintf('\\nConfiguring EELS excitation...\\n');

% Impact parameter
impact = [{impact[0]}, {impact[1]}];

% Beam parameters
beam_energy = {energy};
beam_width = {width};

fprintf('Impact parameter: [%.2f, %.2f] nm\\n', impact(1), impact(2));
fprintf('Beam energy: %.2e eV\\n', beam_energy);
"""
        return code
    
    def _generate_wavelength_loop(self):
        """Generate wavelength loop with optional field calculation."""
        wavelength_range = self.config['wavelength_range']
        calculate_fields = self.config.get('calculate_fields', False)
        excitation_type = self.config['excitation_type']
        
        # Base loop setup
        code = f"""
%% Wavelength Loop
wavelength_range = [{wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]}];
enei = linspace(wavelength_range(1), wavelength_range(2), wavelength_range(3));
n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('              Starting BEM Calculation\\n');
fprintf('================================================================\\n');
fprintf('Wavelength range: %.1f - %.1f nm\\n', wavelength_range(1), wavelength_range(2));
fprintf('Number of wavelengths: %d\\n', n_wavelengths);
fprintf('Number of polarizations: %d\\n', n_polarizations);
fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""
        
        # Add field setup if needed
        if calculate_fields:
            code += self._generate_field_setup()
        
        # Main calculation loop
        code += """
% Start timer
calculation_start = tic;

% Loop over wavelengths
for ien = 1:n_wavelengths
    % Calculate progress percentage
    progress_pct = (ien-1) / n_wavelengths * 100;
    
    % Create progress bar (simple text-based)
    bar_length = 40;
    filled = floor(bar_length * (ien-1) / n_wavelengths);
    bar = ['[' repmat('=', 1, filled) repmat('.', 1, bar_length - filled) ']'];
    
    fprintf('\\r%s %.1f%% | λ = %.1f nm', bar, progress_pct, enei(ien));
    
    % Loop over polarizations
    for ipol = 1:n_polarizations
"""
        
        # Add excitation-specific code
        if excitation_type == 'planewave':
            code += """
        % Plane wave excitation
        exc = planewave(pol(ipol, :), dir(ipol, :), op);
"""
        elif excitation_type == 'dipole':
            code += """
        % Dipole excitation
        pt = compoint(p, dip_pos, op);
        dip = dipole(pt, dip_mom, op);
        exc = dip;
"""
        elif excitation_type == 'eels':
            code += """
        % EELS excitation
        exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
"""
        
        # BEM solution and cross sections
        code += """
        % Solve BEM equation
        sig = bem \\ exc(p, enei(ien));
        
        % Calculate cross sections
        sca(ien, ipol) = exc.sca(sig);
        ext(ien, ipol) = exc.ext(sig);
        abs_cross(ien, ipol) = ext(ien, ipol) - sca(ien, ipol);
"""
        
        # Add field calculation if enabled
        if calculate_fields:
            code += self._generate_field_calculation_in_loop()
        
        # Close loops
        code += """
    end
end

% Complete progress bar
fprintf('\\r[');
fprintf(repmat('=', 1, 40));
fprintf('] 100.0%%\\n');

calculation_time = toc(calculation_start);
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Calculation completed in %.2f seconds (%.2f minutes)\\n', calculation_time, calculation_time/60);
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_field_setup(self):
        """Generate field mesh setup code."""
        field_region = self.config.get('field_region', {})
        mindist = self.config.get('field_mindist', 0.2)
        nmax = self.config.get('field_nmax', 2000)
        field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
        
        x_range = field_region.get('x_range', [-50, 50, 101])
        y_range = field_region.get('y_range', [0, 0, 1])
        z_range = field_region.get('z_range', [0, 0, 1])
        
        code = f"""
%% Field Calculation Setup
fprintf('\\nSetting up field calculation mesh...\\n');

% Determine which wavelength index to calculate fields
"""
        
        if field_wl_idx == 'middle':
            code += "field_wavelength_idx = round(n_wavelengths / 2);\n"
        elif field_wl_idx == 'peak':
            code += "% Will determine peak wavelength after first polarization calculation\n"
            code += "field_wavelength_idx = -1;  % To be determined\n"
        elif isinstance(field_wl_idx, int):
            code += f"field_wavelength_idx = {field_wl_idx};\n"
        else:
            code += "field_wavelength_idx = round(n_wavelengths / 2);\n"
        
        code += f"\nfprintf('Field will be calculated at wavelength index: %d\\n', field_wavelength_idx);\n\n"
        
        # Create mesh grid
        code += "% Create mesh grid for field calculation\n"
        
        # Determine plane type
        if y_range[2] == 1:  # xz-plane
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} + 0 * x_grid;  % xz-plane at y={y_range[0]}
fprintf('Field mesh: xz-plane (y=%.1f), %dx%d points\\n', {y_range[0]}, length(x_field), length(z_field));
"""
        elif z_range[2] == 1:  # xy-plane
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} + 0 * x_grid;  % xy-plane at z={z_range[0]}
fprintf('Field mesh: xy-plane (z=%.1f), %dx%d points\\n', {z_range[0]}, length(x_field), length(y_field));
"""
        else:  # 3D volume
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, y_grid, z_grid] = meshgrid(x_field, y_field, z_field);
fprintf('Field mesh: 3D volume, %dx%dx%d points\\n', length(x_field), length(y_field), length(z_field));
"""
        
        # Initialize meshfield object
        code += f"""
% Initialize meshfield object
fprintf('Initializing meshfield object...\\n');
emesh = meshfield(p, x_grid, y_grid, z_grid, op, 'mindist', {mindist}, 'nmax', {nmax});
fprintf('  - Minimum distance: {mindist} nm\\n');
fprintf('  - Portion size (nmax): {nmax}\\n');
fprintf('  - Total field points: %d\\n', numel(x_grid));

% Initialize field data storage structure
field_data = struct();
"""
        
        return code
    
    def _generate_field_calculation_in_loop(self):
        """Generate field calculation code inside wavelength loop."""
        code = """
        % Calculate electromagnetic fields at selected wavelength
        if ien == field_wavelength_idx
            fprintf('\\n  → Calculating electromagnetic fields at λ = %.1f nm...\\n', enei(ien));
            field_calc_start = tic;
            
            % Calculate induced fields
            e_induced = emesh(sig);
            
            % Calculate incoming fields
            e_incoming = emesh(exc.field(emesh.pt, enei(ien)));
            
            % Total electric field
            e_total = e_induced + e_incoming;
            
            % Calculate field intensity (|E|^2)
            e_intensity = dot(e_total, e_total, 3);
            
            % Calculate incident field intensity
            e0_intensity = dot(e_incoming, e_incoming, 3);
            
            % Field enhancement |E|/|E0|
            enhancement = sqrt(e_intensity ./ e0_intensity);
            
            % Store field data for this polarization
            field_data(ipol).polarization = pol(ipol, :);
            field_data(ipol).wavelength = enei(ien);
            field_data(ipol).e_total = e_total;
            field_data(ipol).e_induced = e_induced;
            field_data(ipol).e_incoming = e_incoming;
            field_data(ipol).enhancement = enhancement;
            field_data(ipol).intensity = e_intensity;
            field_data(ipol).x_grid = x_grid;
            field_data(ipol).y_grid = y_grid;
            field_data(ipol).z_grid = z_grid;
            
            field_calc_time = toc(field_calc_start);
            fprintf('  → Field calculation completed in %.2f seconds\\n', field_calc_time);
        end
"""
        return code
    
    def _generate_save_results(self):
        """Generate code to save simulation results."""
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = """
%% Save Results
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Saving results...\\n');

% Prepare data structure
results = struct();
results.wavelength = enei;
results.scattering = sca;
results.extinction = ext;
results.absorption = abs_cross;
results.polarizations = pol;
results.propagation_dirs = dir;
results.calculation_time = calculation_time;
"""
        
        if calculate_fields:
            code += """
% Save field data if calculated
if exist('field_data', 'var') && ~isempty(field_data)
    results.fields = field_data;
    fprintf('Field data included in results (polarizations: %d)\\n', length(field_data));
end
"""
        
        code += """
% Save to .mat file
save('simulation_results.mat', 'results');
fprintf('✓ Results saved to: simulation_results.mat\\n');

% Save cross sections to text file
fid = fopen('simulation_results.txt', 'w');
fprintf(fid, 'Wavelength(nm)\\t');
for ipol = 1:n_polarizations
    fprintf(fid, 'Sca_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    fprintf(fid, 'Ext_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    if ipol < n_polarizations
        fprintf(fid, 'Abs_pol%d\\t', ipol);
    else
        fprintf(fid, 'Abs_pol%d', ipol);
    end
end
fprintf(fid, '\\n');

for i = 1:length(enei)
    fprintf(fid, '%.2f\\t', enei(i));
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', sca(i, ipol));
    end
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', ext(i, ipol));
    end
    for ipol = 1:n_polarizations
        if ipol < n_polarizations
            fprintf(fid, '%.6e\\t', abs_cross(i, ipol));
        else
            fprintf(fid, '%.6e', abs_cross(i, ipol));
        end
    end
    fprintf(fid, '\\n');
end
fclose(fid);
fprintf('✓ Cross sections saved to: simulation_results.txt\\n');
"""
        
        if calculate_fields:
            code += """
% Save field data to separate MAT file
if exist('field_data', 'var') && ~isempty(field_data)
    save('field_data.mat', 'field_data', '-v7.3');
    fprintf('✓ Field data saved to: field_data.mat\\n');
end
"""
        
        code += """
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_footer(self):
        """Generate script footer."""
        code = """
fprintf('\\n');
fprintf('=== MNPBEM Simulation Completed Successfully ===\\n');
fprintf('\\n');
"""
        return code
    
    def _python_list_to_matlab(self, python_list):
        """Convert Python list to MATLAB array string."""
        if not python_list:
            return '[]'
        
        # Handle 2D array (list of lists)
        if isinstance(python_list[0], (list, tuple)):
            rows = []
            for row in python_list:
                row_str = ', '.join([str(x) for x in row])
                rows.append(row_str)
            return '[' + '; '.join(rows) + ']'
        else:
            # Handle 1D array
            return '[' + ', '.join([str(x) for x in python_list]) + ']'
