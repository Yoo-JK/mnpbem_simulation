"""
MATLAB Code Generator

Generates complete MATLAB simulation scripts with field calculation support.
Supports nonlocal quantum corrections for sub-nanometer gaps.
Supports parallel computing with parfor (single node, multiple cores).
"""
import os
import numpy as np
from .nonlocal_generator import NonlocalGenerator


class MatlabCodeGenerator:
    """Generates complete MATLAB simulation code."""
    
    def __init__(self, config, verbose=False):
        self.config = config
        self.verbose = verbose
        self.nonlocal_gen = NonlocalGenerator(config, verbose)
    
    def generate_complete_script(self, geometry_code, material_code):
        """Generate complete MATLAB simulation script."""

        self._extract_closed_args(material_code)
        
        # Header
        header = self._generate_header()
        
        # Options
        options = self._generate_options()
        
        # Geometry
        geometry = geometry_code
        
        # Materials
        materials = material_code
        
        # Comparticle creation
        comparticle = self._generate_comparticle()
        
        # Validation (if nonlocal)
        validation = self._validate_nonlocal_setup()

        # Green function tabulation
        greentab = self._generate_substrate_greentab()
        
        # BEM solver
        bem_solver = self._generate_bem_solver()
        
        # Excitation
        excitation = self._generate_excitation()

        # Wavelength loop (with chunking support!)
        chunk_size = self.config.get('wavelength_chunk_size', None)
        if chunk_size:
            # Use memory-efficient chunking
            wavelength_loop = self._generate_wavelength_loop_with_chunking()
            if self.verbose:
                print(f"✓ Using wavelength chunking: {chunk_size} wavelengths per chunk")
        else:
            # Use standard loop
            wavelength_loop = self._generate_wavelength_loop()
            if self.verbose:
                print("✓ Using standard wavelength loop (no chunking)")
        
        # Save results
        save_results = self._generate_save_results()
        
        # Footer (now with parallel cleanup!)
        footer = self._generate_footer()
        
        # Combine all parts
        complete_code = f"""{header}

{options}

{geometry}

{materials}

{comparticle}

{validation}

{greentab}

{bem_solver}

{excitation}

{wavelength_loop}

{save_results}

{footer}
"""
        return complete_code
    
    def _generate_header(self):
        """Generate script header."""
        code = """% MNPBEM Simulation Script
% Auto-generated by MNPBEM Automation Pipeline
%
% DO NOT EDIT THIS FILE MANUALLY
% Modify the configuration file instead and regenerate

clear all;
close all;
clc;

fprintf('=== MNPBEM Simulation Started ===\\n');
fprintf('Structure: %s\\n', '{structure}');
fprintf('Simulation Type: %s\\n', '{sim_type}');
""".format(
            structure=self.config['structure'],
            sim_type=self.config['simulation_type']
        )
        return code
    
    def _generate_options(self):
        """Generate BEM options with proper settings."""
        sim_type = self.config['simulation_type']
        use_mirror = self.config.get('use_mirror_symmetry', False)
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        use_substrate = self.config.get('use_substrate', False)

        if use_substrate and sim_type != 'ret':
            raise ValueError(
                "Substrate simulations require 'ret' (retarded) simulation type. "
                f"Current simulation_type is '{sim_type}'. "
                "Please set: args['simulation_type'] = 'ret'"
            )
        
        refine = self.config.get('refine', 3 if use_nonlocal else 1)
        relcutoff = self.config.get('relcutoff', 2 if use_iterative else 3)
        
        code = f"""
%% BEM Options
fprintf('\\nSetting up BEM options...\\n');
"""
        
        # Base options
        if sim_type == 'stat':
            code += "op = bemoptions( 'sim', 'stat', 'interp', 'curv' );\n"
        else:
            code += "op = bemoptions( 'sim', 'ret', 'interp', 'curv' );\n"
        
        code += f"op.refine = {refine};\n"

        if use_substrate:
            code += """
fprintf('  ✓ Substrate mode enabled\\n');
fprintf('  ⚠ Green function tabulation will be required\\n');
"""
        
        # Mirror symmetry
        if use_mirror:
            if isinstance(use_mirror, str):
                sym = use_mirror
            else:
                sym = 'xy'
            code += f"op.sym = '{sym}';\n"
            code += f"fprintf('  ✓ Mirror symmetry: {sym}\\n');\n"
        
        # Nonlocal options (high precision integration)
        if use_nonlocal:
            nonlocal_opts = self.nonlocal_gen.generate_bem_options()
            code += nonlocal_opts
        
        # Iterative solver options
        if use_iterative:
            code += f"""
%% Iterative Solver Options
relcutoff = {relcutoff};
fprintf('  ✓ Iterative solver: relcutoff=%d\\n', relcutoff);
"""
        
        code += "\nfprintf('✓ BEM options configured\\n');\n"
        
        return code
    
    def _generate_parallel_setup(self):
        """Generate parallel pool setup code."""
        num_workers = self.config.get('num_workers', 'auto')
        
        code = """
%% Parallel Computing Setup
fprintf('\\n=== Setting up Parallel Computing ===\\n');

"""
        
        # Determine number of workers based on config
        if num_workers == 'env':
            code += """% Get number of workers from environment variable
if ~isempty(getenv('MNPBEM_NUM_WORKERS'))
    requested_workers = str2double(getenv('MNPBEM_NUM_WORKERS'));
    fprintf('Reading from environment: MNPBEM_NUM_WORKERS=%d\\n', requested_workers);
elseif ~isempty(getenv('SLURM_CPUS_PER_TASK'))
    requested_workers = str2double(getenv('SLURM_CPUS_PER_TASK'));
    fprintf('Detected Slurm environment: SLURM_CPUS_PER_TASK=%d\\n', requested_workers);
else
    requested_workers = feature('numcores');
    fprintf('Auto-detected available cores: %d\\n', requested_workers);
end
"""
        elif num_workers == 'auto':
            code += """% Auto-detect available cores
requested_workers = feature('numcores');
fprintf('Auto-detected available cores: %d\\n', requested_workers);
"""
        elif isinstance(num_workers, int):
            code += f"""% Using specified number of workers
requested_workers = {num_workers};
fprintf('Using specified workers: %d\\n', requested_workers);
"""
        else:
            code += """% Default to 1 worker (serial)
requested_workers = 1;
fprintf('Using default: 1 worker (serial execution)\\n');
"""
        
        code += """
% Create parallel pool
try
    % Check if pool already exists
    existing_pool = gcp('nocreate');
    
    if isempty(existing_pool)
        % No existing pool, create new one
        if requested_workers > 1
            fprintf('Creating parallel pool with %d workers...\\n', requested_workers);
            pool = parpool('local', requested_workers);
            fprintf('✓ Parallel pool created successfully: %d workers\\n', pool.NumWorkers);
            parallel_enabled = true;
        else
            fprintf('Serial execution mode (1 worker)\\n');
            pool = [];
            parallel_enabled = false;
        end
    else
        % Pool exists, use it
        pool = existing_pool;
        fprintf('✓ Using existing parallel pool: %d workers\\n', pool.NumWorkers);
        parallel_enabled = true;
    end
    
catch ME
    fprintf('⚠ Warning: Failed to create parallel pool\\n');
    fprintf('Error: %s\\n', ME.message);
    fprintf('Continuing with serial execution...\\n');
    pool = [];
    parallel_enabled = false;
end

fprintf('=== Parallel Setup Complete ===\\n\\n');
"""
        return code
    
    def _generate_parallel_cleanup(self):
        """
        Generate safe parallel pool cleanup code.
        
        ✅ IMPROVEMENTS:
        1. Longer timeout for worker termination (15 seconds)
        2. Force kill if timeout
        3. Better verification
        """
        code = """
%% Parallel Computing Cleanup (IMPROVED!)
if exist('parallel_enabled', 'var') && parallel_enabled && ~isempty(gcp('nocreate'))
    fprintf('\\nCleaning up parallel pool...\\n');
    
    try
        pool = gcp('nocreate');
        if ~isempty(pool)
            % Get pool info
            n_workers = pool.NumWorkers;
            fprintf('  Shutting down %d workers...\\n', n_workers);
            
            % Delete the pool
            delete(pool);
            
            % IMPROVED: Wait with timeout for complete termination
            fprintf('  Waiting for workers to terminate...\\n');
            timeout = 15;  % 15 seconds timeout (increased from 2!)
            start_time = tic;
            
            while ~isempty(gcp('nocreate')) && toc(start_time) < timeout
                pause(0.5);
                % Print status every 3 seconds
                if mod(toc(start_time), 3) < 0.5
                    fprintf('    Still waiting... (%.1f seconds elapsed)\\n', toc(start_time));
                end
            end
            
            % Verify pool is completely gone
            remaining_pool = gcp('nocreate');
            if isempty(remaining_pool)
                fprintf('  ✓ Parallel pool closed successfully\\n');
            else
                fprintf('  WARNING: Pool cleanup timeout after %.1f seconds\\n', timeout);
                fprintf('     Some workers may still be running\\n');
                fprintf('     MATLAB will force-terminate on exit\\n');
                % Try force delete one more time
                try
                    delete(gcp('nocreate'));
                catch
                    % Ignore errors - will be cleaned up on exit
                end
            end
        end
    catch ME
        fprintf('  Warning during pool cleanup: %s\\n', ME.message);
        fprintf('     Continuing with exit anyway...\\n');
    end
end
"""
        return code
    
    def _generate_comparticle(self):
        """Generate comparticle object creation with visualization."""
        
        # Get closed indices from material manager
        closed_args = self._closed_args
        
        # Check if substrate is used
        use_substrate = self.config.get('use_substrate', False)

        if use_substrate:
            substrate = self.config.get('substrate', {})
            substrate_position = substrate.get('position', 0)
        
        code = """
%% Create Comparticle Object
fprintf('\\nCreating comparticle object...\\n');
p = comparticle(epstab, particles, inout, """ + closed_args + """, op);
fprintf('Comparticle created with %d boundary elements\\n', p.n);

%% Visualize and Save Structure
fprintf('\\nGenerating structure visualizations...\\n');

try
    n_particles = length(particles);
    
    % Define colors
    core_color = [1.0, 0.7, 0.3];  % Gold/orange for core
    shell_color_1 = [0.7, 0.85, 1.0];  % Light blue
    shell_color_2 = [0.5, 0.7, 0.95];  % Medium blue
    shell_color_3 = [0.3, 0.5, 0.9];   % Darker blue
    substrate_color = [0.85, 0.85, 0.85];  % Light gray
    
"""
        
        # Add substrate parameters
        if use_substrate:
            code += f"""    % Substrate parameters
    has_substrate = true;
    z_substrate = {substrate_position};
"""
        else:
            code += """    % No substrate
    has_substrate = false;
"""
        
        code += """    
    % Get particle bounds for plotting
    x_lim = [min(p.pos(:,1)), max(p.pos(:,1))];
    y_lim = [min(p.pos(:,2)), max(p.pos(:,2))];
    z_lim = [min(p.pos(:,3)), max(p.pos(:,3))];
    
    % Expand limits for substrate visualization
    x_expand = (x_lim(2) - x_lim(1)) * 0.3;
    y_expand = (y_lim(2) - y_lim(1)) * 0.3;
    x_range = [x_lim(1) - x_expand, x_lim(2) + x_expand];
    y_range = [y_lim(1) - y_expand, y_lim(2) + y_expand];
    
    % ========== 3D View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    % Check if single or multi-particle structure
    if n_particles == 1
        % Single particle: simple plot
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        % Multi-particle (core-shell): plot with progressive transparency
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                % Core: opaque, gold color
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                % Shells: progressively more transparent
                shell_idx = i - 1;
                
                % Select transparency and color
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    % General case
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
        
        % Add legend for multi-layer structures
        legend_entries = cell(n_particles, 1);
        legend_entries{1} = 'Core';
        for i = 2:n_particles
            legend_entries{i} = sprintf('Shell %d', i-1);
        end
        legend(legend_entries, 'Location', 'northeast', 'FontSize', 10);
    end
    
    % Draw substrate interface (3D view)
    if has_substrate
        % Create substrate plane
        [X_sub, Y_sub] = meshgrid(x_range, y_range);
        Z_sub = ones(size(X_sub)) * z_substrate;
        surf(X_sub, Y_sub, Z_sub, 'FaceColor', substrate_color, ...
             'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Draw interface outline
        plot3([x_range(1), x_range(2), x_range(2), x_range(1), x_range(1)], ...
              [y_range(1), y_range(1), y_range(2), y_range(2), y_range(1)], ...
              [z_substrate, z_substrate, z_substrate, z_substrate, z_substrate], ...
              'k-', 'LineWidth', 2);
        
        % Add label
        text(x_range(2)*0.8, y_range(2)*0.8, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('3D View', 'FontSize', 14, 'FontWeight', 'bold');
    view(45, 30);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver3(0, 0, 0, arrow_len, 0, 0, 'Color', 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, arrow_len, 0, 'Color', 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, 0, arrow_len, 'Color', 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 0, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0, 0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    axis equal;
    axis off;
    view(45, 30);
    xlim([-0.3, 1.5]);
    ylim([-0.3, 1.5]);
    zlim([-0.3, 1.5]);
    
    print('structure_3D.png', '-dpng', '-r300');
    fprintf('  ✓ 3D view saved\\n');
    close(fig);
    
    % ========== XY View (Top View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Substrate outline in XY view
    if has_substrate
        rectangle('Position', [x_range(1), y_range(1), ...
                              x_range(2)-x_range(1), y_range(2)-y_range(1)], ...
                 'EdgeColor', 'k', 'LineWidth', 2, 'LineStyle', '--');
        text(x_range(2)*0.85, y_range(2)*0.85, ...
             sprintf('Substrate z=%.1f', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k');
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('XY View (Top View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 90);
    grid on;
    box on;
    
    print('structure_XY.png', '-dpng', '-r300');
    fprintf('  ✓ XY view saved\\n');
    close(fig);
    
    % ========== YZ View (Side View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (YZ view - FIXED!)
    if has_substrate
        % Substrate line: x=0 plane, along y-axis, at z=z_substrate
        plot3([0, 0], ...
              [y_range(1), y_range(2)], ...
              [z_substrate, z_substrate], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        y_fill = [y_range(1), y_range(2), y_range(2), y_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(y_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator: vertical line at y=y_mid
            y_mid = mean(y_range);
            plot3([0, 0], [y_mid, y_mid], [particle_bottom, z_substrate], ...
                  'r-', 'LineWidth', 2);
            text(0, y_mid, (particle_bottom + z_substrate)/2, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(0, y_range(2)*0.85, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('YZ View (Side View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(90, 0);
    grid on;
    box on;
    
    print('structure_YZ.png', '-dpng', '-r300');
    fprintf('  ✓ YZ view saved\\n');
    close(fig);
    
    % ========== ZX View (Front View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (ZX view - FIXED!)
    if has_substrate
        % Substrate line: y=0 plane, along x-axis, at z=z_substrate
        plot3([x_range(1), x_range(2)], ...
              [0, 0], ...
              [z_substrate, z_substrate], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        x_fill = [x_range(1), x_range(2), x_range(2), x_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(x_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator: vertical line at x=x_mid
            x_mid = mean(x_range);
            plot3([x_mid, x_mid], [0, 0], [particle_bottom, z_substrate], ...
                  'r-', 'LineWidth', 2);
            text(x_mid, 0, (particle_bottom + z_substrate)/2, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(x_range(2)*0.85, 0, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('ZX View (Front View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 0);
    grid on;
    box on;
    
    print('structure_ZX.png', '-dpng', '-r300');
    fprintf('  ✓ ZX view saved\\n');
    close(fig);
    
    fprintf('  ✓ All structure visualizations completed!\\n');
    
catch ME
    fprintf('  Warning: Could not save structure plots: %s\\n', ME.message);
end
"""

        return code
    
    def _validate_nonlocal_setup(self):
        """Validate that nonlocal setup is correct."""
        if not self.nonlocal_gen.is_needed():
            return ""
        
        code = """
%% Validate Nonlocal Setup
fprintf('\\n=== Validating Nonlocal Setup ===\\n');

% Check number of particles
n_particles = length(particles);
fprintf('  Number of particle boundaries: %d\\n', n_particles);

% Check epstab
n_materials = length(epstab);
fprintf('  Number of materials in epstab: %d\\n', n_materials);

% Check inout matrix
[n_boundaries, ~] = size(inout);
fprintf('  Number of boundaries in inout: %d\\n', n_boundaries);

% Validation
if n_particles ~= n_boundaries
    error('Mismatch: %d particles but %d boundaries in inout!', n_particles, n_boundaries);
end

fprintf('✓ Nonlocal setup validated\\n');
"""
        return code

    def _generate_substrate_greentab(self):
        """Generate Green function tabulation with field point coverage."""
        use_substrate = self.config.get('use_substrate', False)
        sim_type = self.config['simulation_type']
        
        if not (use_substrate and sim_type == 'ret'):
            return ""
        
        nz = self.config.get('greentab_nz', 30)
        scale = self.config.get('greentab_scale', 1.5)
        
        wavelength_range = self.config['wavelength_range']
        wl_min = wavelength_range[0]
        wl_max = wavelength_range[1]
        wl_num = wavelength_range[2]
        
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = f"""
%% Green Function Tabulation (Required for Substrate)
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('        Setting up Green Function Table for Substrate          \\n');
fprintf('================================================================\\n');

% CRITICAL: Define actual simulation wavelengths FIRST
enei = linspace({wl_min}, {wl_max}, {wl_num});
fprintf('Simulation wavelengths: %.1f to %.1f nm (%d points)\\n', ...
        min(enei), max(enei), length(enei));
"""

        # ✅ FIX: Field points를 tabulation에 포함!
        if calculate_fields:
            field_region = self.config.get('field_region', {})
            x_range = field_region.get('x_range', [-50, 50, 101])
            y_range = field_region.get('y_range', [0, 0, 1])
            z_range = field_region.get('z_range', [0, 0, 1])
            
            code += """
% Set up field points for Green function tabulation
fprintf('\\nPreparing field mesh for tabulation...\\n');
"""
        
            if y_range[2] == 1:  # xz-plane
                code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
            elif z_range[2] == 1:  # xy-plane
                code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
        
            code += """
% Store grid shape for later use
grid_shape = size(x_grid);
fprintf('Field grid: %dx%d points\\n', grid_shape(1), grid_shape(2));

% Create compoint object for field mesh (CRITICAL for tabulation!)
fprintf('  Creating compoint for field mesh...\\n');
pt_field = compoint(p, [x_grid(:), y_grid(:), z_grid(:)], op);
fprintf('  → Field points: %d\\n', pt_field.n);

% Check compatibility: particle + field points
if ~exist('greentab', 'var') || ~greentab.ismember(layer, enei, {p, pt_field})
    fprintf('Creating new Green function table...\\n');
    
    % CRITICAL FIX: Include BOTH particle and field points in tabulation!
    fprintf('  Creating tabulation grid (particle + field points)...\\n');
"""
        
            code += f"""    tab = tabspace(layer, {{p, pt_field}}, 'nz', {nz}, 'scale', {scale});
    
    % Initialize Green function table
    fprintf('  Initializing compgreentablayer...\\n');
    greentab = compgreentablayer(layer, tab);
    
    % Precompute for actual simulation wavelengths
    fprintf('  Precomputing Green functions for %d wavelengths...\\n', length(enei));
    fprintf('  This may take several minutes...\\n');
    
    tic_start = tic;
    greentab = set(greentab, enei, op);
    time_elapsed = toc(tic_start);
    
    fprintf('  ✓ Green function table ready (%.1f seconds)\\n', time_elapsed);
else
    fprintf('✓ Using existing compatible Green function table\\n');
end
"""
        else:
            # No field calculation: particle only (original behavior)
            code += """
% No field calculation: tabulate for particle only
if ~exist('greentab', 'var') || ~greentab.ismember(layer, enei, p)
    fprintf('Creating new Green function table...\\n');
    
    % Create tabulation grid for particle ONLY
    fprintf('  Creating tabulation grid (particle only)...\\n');
"""

            code += f"""    tab = tabspace(layer, p, 'nz', {nz}, 'scale', {scale});
    
    % Initialize Green function table
    fprintf('  Initializing compgreentablayer...\\n');
    greentab = compgreentablayer(layer, tab);
    
    % Precompute for actual simulation wavelengths
    fprintf('  Precomputing Green functions for %d wavelengths...\\n', length(enei));
    fprintf('  This may take several minutes...\\n');
    
    tic_start = tic;
    greentab = set(greentab, enei, op);
    time_elapsed = toc(tic_start);
    
    fprintf('  ✓ Green function table ready (%.1f seconds)\\n', time_elapsed);
else
    fprintf('✓ Using existing compatible Green function table\\n');
end
"""

        code += """
% Add to options
op.greentab = greentab;
fprintf('✓ Green function table added to BEM options\\n\\n');
"""

        return code
    
    def _generate_bem_solver(self):
        """Generate BEM solver initialization code."""
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        
        code = """
%% Initialize BEM Solver
fprintf('\\nInitializing BEM solver...\\n');
"""
        
        if use_iterative:
            code += """
% Configure iterative solver options
fprintf('  Using iterative BEM solver (for large structures)\\n');
op.iter = bemiter.options( 'output', 1 );
op.iter.tol = 1e-4;
op.iter.maxit = 200;
op.iter.solver = 'gmres';
op.iter.cleaf = 200;
op.iter.htol = 1e-6;
op.iter.kmax = [4, 100];
op.iter.fadmiss = @(rad1,rad2,dist) 2.5 * min(rad1,rad2) < dist;

fprintf('  Iterative solver parameters:\\n');
fprintf('    - Solver: %s\\n', op.iter.solver);
fprintf('    - Tolerance: %g\\n', op.iter.tol);
fprintf('    - Max iterations: %d\\n', op.iter.maxit);
"""
        
        # Add nonlocal refinement if enabled
        if use_nonlocal:
            refine_code = self.nonlocal_gen.generate_refine_function('p')
            
            code += f"""
% Nonlocal refinement for cover layer boundaries
{refine_code}

% Initialize solver with refined integration function
"""
            if use_iterative:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('✓ Nonlocal BEM solver initialized (iterative)\\n');
"""
            else:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('✓ Nonlocal BEM solver initialized (direct)\\n');
"""
        else:
            # Standard BEM solver
            code += """
% Initialize BEM solver
try
    bem = bemsolver(p, op);
    fprintf('BEM solver initialized successfully\\n');
    fprintf('  - Boundary elements: %d\\n', size(p.pos, 1));
catch ME
    fprintf('Error initializing BEM solver: %s\\n', ME.message);
    rethrow(ME);
end
"""
        
        return code
    
    def _generate_excitation(self):
        """Generate excitation configuration."""
        excitation_type = self.config['excitation_type']
        
        if excitation_type == 'planewave':
            code = self._generate_planewave_excitation()
        elif excitation_type == 'dipole':
            code = self._generate_dipole_excitation()
        elif excitation_type == 'eels':
            code = self._generate_eels_excitation()
        else:
            raise ValueError(f"Unknown excitation type: {excitation_type}")
        
        return code
    
    def _generate_planewave_excitation(self):
        """Generate plane wave excitation code."""
        polarizations = self.config['polarizations']
        propagation_dirs = self.config['propagation_dirs']
        
        pol_str = self._python_list_to_matlab(polarizations)
        dir_str = self._python_list_to_matlab(propagation_dirs)
        
        code = f"""
%% Plane Wave Excitation
fprintf('\\nConfiguring plane wave excitation...\\n');

% Polarization vectors
pol = {pol_str};

% Propagation directions
dir = {dir_str};

fprintf('Number of polarizations: %d\\n', size(pol, 1));
fprintf('Number of propagation directions: %d\\n', size(dir, 1));
"""
        return code
    
    def _generate_dipole_excitation(self):
        """Generate dipole excitation code."""
        position = self.config.get('dipole_position', [0, 0, 15])
        moment = self.config.get('dipole_moment', [0, 0, 1])
        
        pos_str = self._python_list_to_matlab([position])
        mom_str = self._python_list_to_matlab([moment])
        
        code = f"""
%% Dipole Excitation
fprintf('\\nConfiguring dipole excitation...\\n');

% Dipole position
dip_pos = {pos_str};

% Dipole moment
dip_mom = {mom_str};

fprintf('Dipole position: [%.2f, %.2f, %.2f] nm\\n', dip_pos(1), dip_pos(2), dip_pos(3));
"""
        return code
    
    def _generate_eels_excitation(self):
        """Generate EELS excitation code."""
        impact = self.config.get('impact_parameter', [10, 0])
        energy = self.config.get('beam_energy', 200e3)
        width = self.config.get('beam_width', 0.2)
        
        code = f"""
%% EELS Excitation
fprintf('\\nConfiguring EELS excitation...\\n');

% Impact parameter
impact = [{impact[0]}, {impact[1]}];

% Beam parameters
beam_energy = {energy};
beam_width = {width};

fprintf('Impact parameter: [%.2f, %.2f] nm\\n', impact(1), impact(2));
fprintf('Beam energy: %.2e eV\\n', beam_energy);
"""
        return code

    def _generate_wavelength_loop(self):
        """
        Generate wavelength loop with proper parallel execution.
        
        CRITICAL FIXES (2024-12-03):
        1. Excitation MUST be initialized OUTSIDE parfor loop
        2. MNPBEM processes ALL polarizations at once (no polarization loop needed)
        3. Improved error handling and pool cleanup
        
        Based on MNPBEM official example: Demo/planewave/ret/demospecret9.m
        """
        wavelength_range = self.config['wavelength_range']
        calculate_fields = self.config.get('calculate_fields', False)
        excitation_type = self.config['excitation_type']
        use_parallel = self.config.get('use_parallel', False)
        
        code = f"""
%% Wavelength Loop
% Note: 'enei' was already defined in Green function section if substrate is used
if ~exist('enei', 'var')
    enei = linspace({wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]});
end

n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('              Starting BEM Calculation\\n');
fprintf('================================================================\\n');
fprintf('Wavelength range: %.1f - %.1f nm (%d points)\\n', ...
        min(enei), max(enei), n_wavelengths);
fprintf('Number of polarizations: %d\\n', n_polarizations);
"""
        
        # Add parallel setup if enabled
        if use_parallel:
            code += self._generate_parallel_setup()
        
        code += """fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""
        
        if calculate_fields:
            code += self._generate_field_setup()
        
        # CRITICAL FIX 1: Initialize excitation BEFORE the loop!
        code += """
%% Initialize Excitation Object (CRITICAL: Must be before parallel loop!)
fprintf('\\nInitializing excitation object...\\n');
"""
    
        if excitation_type == 'planewave':
            code += """% Plane wave excitation (ALL polarizations at once)
exc = planewave(pol, dir, op);
fprintf('  ✓ Plane wave excitation initialized\\n');
fprintf('    - Polarizations: %d\\n', size(pol, 1));
fprintf('    - Propagation directions: %d\\n', size(dir, 1));
"""
        elif excitation_type == 'dipole':
            code += """pt = compoint(p, dip_pos, op);
exc = dipole(pt, dip_mom, op);
fprintf('  ✓ Dipole excitation initialized\\n');
"""
        elif excitation_type == 'eels':
            code += """exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
fprintf('  ✓ EELS excitation initialized\\n');
"""
    
        code += """
% Start timer
calculation_start = tic;

"""
    
        # Generate loop - parfor if parallel enabled, regular for otherwise
        if use_parallel:
            code += """% ========================================
% PARALLEL EXECUTION (parfor loop)
% ========================================
if exist('parallel_enabled', 'var') && parallel_enabled
    fprintf('\\n Using PARALLEL execution (parfor loop)\\n');
    fprintf('    Progress updates may appear out of order\\n');
    fprintf('    Each worker computes independently\\n\\n');
    
    %% PARALLEL LOOP (FIXED!)
    % - Excitation object (exc) is already initialized
    % - MNPBEM processes ALL polarizations at once
    % - No need for inner polarization loop
    parfor ien = 1:n_wavelengths
        try
            % Progress indicator (less frequent for parallel)
            if mod(ien-1, max(1, floor(n_wavelengths/10))) == 0
                fprintf('  [Worker] Processing wavelength %d/%d (λ = %.1f nm)\\n', ...
                        ien, n_wavelengths, enei(ien));
            end
            
            % FIXED: Just use pre-initialized exc object!
            % MNPBEM automatically handles ALL polarizations in one call
            sig = bem \\ exc(p, enei(ien));
            
            % Extract cross sections (returns vector for all polarizations)
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            % Error handling: print error but continue with other wavelengths
            fprintf('  ERROR at wavelength %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            % Leave zeros for this wavelength
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
    end
    
    fprintf('\\n✓ Parallel computation completed\\n');
    
else
    % ========================================
    % SERIAL EXECUTION (for loop)
    % ========================================
    fprintf('\\n Using SERIAL execution (for loop)\\n\\n');
"""
        else:
            # Serial execution only
            code += """% ========================================
% SERIAL EXECUTION (for loop)
% ========================================
fprintf('\\nStarting wavelength loop (serial execution)...\\n\\n');
"""
    
        # FIXED: Serial loop without polarization loop
        code += """
    % Progress bar
    multiWaitbar('BEM Calculation', 0, 'Color', 'g', 'CanCancel', 'on');
    
    %% SERIAL LOOP (FIXED!)
    for ien = 1:n_wavelengths
        % Update progress bar
        multiWaitbar('BEM Calculation', ien / n_wavelengths);
        
        % Text progress indicator
        if mod(ien-1, max(1, floor(n_wavelengths/20))) == 0
            fprintf('  Progress: %d/%d (λ = %.1f nm, %.1f%%)\\n', ...
                    ien, n_wavelengths, enei(ien), 100*ien/n_wavelengths);
        end
        
        try
            % FIXED: Use pre-initialized exc object
            % MNPBEM handles ALL polarizations automatically
            sig = bem \\ exc(p, enei(ien));
            
            % Extract cross sections (vector for all polarizations)
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            fprintf('  ⚠ ERROR at wavelength %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
"""
    
        if calculate_fields:
            code += self._generate_field_calculation_in_loop()
        
        code += """    end
    
    % Close waitbar
    multiWaitbar('CloseAll');
    fprintf('\\n✓ Serial computation completed\\n');
"""
        
        if use_parallel:
            code += """end  % End of parallel/serial decision
"""
        
        # Timing
        code += """
% Calculation timing
calculation_time = toc(calculation_start);
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Calculation completed in %.2f seconds (%.2f minutes)\\n', ...
        calculation_time, calculation_time/60);
fprintf('Average time per wavelength: %.2f seconds\\n', ...
        calculation_time / n_wavelengths);
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_field_setup(self):
        """Generate field mesh setup - AFTER greentab."""
        use_substrate = self.config.get('use_substrate', False)
        
        code = """
%% Field Calculation Setup
fprintf('\\nSetting up field calculation mesh...\\n');

% Select wavelength for field calculation
"""

        field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
        
        if field_wl_idx == 'middle':
            code += """% Use middle wavelength
field_wavelength_idx = round(n_wavelengths / 2);
"""
        elif field_wl_idx == 'peak':
            code += """% Find absorption peak wavelength
fprintf('  Finding absorption peak...\\n');

% Average absorption over polarizations
abs_avg = mean(abs_cross, 2);

% Find maximum
[max_abs, field_wavelength_idx] = max(abs_avg);

fprintf('  → Peak absorption: %.2e nm^2 at λ = %.1f nm (index %d)\\n', ...
        max_abs, enei(field_wavelength_idx), field_wavelength_idx);
"""
        elif field_wl_idx == 'peak_ext':
            code += """% Find extinction peak wavelength
fprintf('  Finding extinction peak...\\n');

% Average extinction over polarizations
ext_avg = mean(ext, 2);

% Find maximum
[max_ext, field_wavelength_idx] = max(ext_avg);

fprintf('  → Peak extinction: %.2e nm^2 at λ = %.1f nm (index %d)\\n', ...
        max_ext, enei(field_wavelength_idx), field_wavelength_idx);
"""
        elif field_wl_idx == 'peak_sca':
            code += """% Find scattering peak wavelength
fprintf('  Finding scattering peak...\\n');

% Average scattering over polarizations
sca_avg = mean(sca, 2);

% Find maximum
[max_sca, field_wavelength_idx] = max(sca_avg);

fprintf('  → Peak scattering: %.2e nm^2 at λ = %.1f nm (index %d)\\n', ...
        max_sca, enei(field_wavelength_idx), field_wavelength_idx);
"""
        elif isinstance(field_wl_idx, int):
            code += f"""% Use specified wavelength index
field_wavelength_idx = {field_wl_idx};
"""
        else:
            code += """% Default: use middle wavelength
field_wavelength_idx = round(n_wavelengths / 2);
"""
        
        code += """
fprintf('Field calculation at wavelength: λ = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);

"""
    
        if use_substrate:
            mindist = self.config.get('field_mindist', 0.5)
            nmax = self.config.get('field_nmax', 2000)
            
            code += f"""% Substrate mode: meshfield with pre-computed greentab
% Reshape grids back to original shape
x_grid = reshape(x_grid, grid_shape);
y_grid = reshape(y_grid, grid_shape);  
z_grid = reshape(z_grid, grid_shape);

% Create meshfield using op with greentab
fprintf('  Creating meshfield...\\n');
emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', {mindist}, 'nmax', {nmax});
fprintf('  ✓ Meshfield ready with %d points\\n', emesh.pt.n);
"""
        else:
            # Standard non-substrate field setup
            field_region = self.config.get('field_region', {})
            mindist = self.config.get('field_mindist', 0.2)
            nmax = self.config.get('field_nmax', 2000)
            x_range = field_region.get('x_range', [-50, 50, 101])
            y_range = field_region.get('y_range', [0, 0, 1])
            z_range = field_region.get('z_range', [0, 0, 1])
            
            if y_range[2] == 1:  # xz-plane
                code += f"""% Create field grid: xz-plane
x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
            elif z_range[2] == 1:  # xy-plane
                code += f"""% Create field grid: xy-plane
x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
        
            code += f"""
% Create meshfield
emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', {mindist}, 'nmax', {nmax});
fprintf('  ✓ Meshfield created: %d points\\n', numel(x_grid));
"""
    
        code += """
% Initialize field data storage
field_data = struct();
"""
    
        return code
    
    def _generate_field_calculation_in_loop(self):
        """Generate field calculation - same for both substrate and non-substrate."""
        code = """
        % Calculate fields at selected wavelength
        if ien == field_wavelength_idx
            fprintf('\\n  → Calculating fields at λ = %.1f nm...\\n', enei(ien));
            field_calc_start = tic;
            
            e_induced = emesh(sig);
            e_incoming = emesh(exc.field(emesh.pt, enei(ien)));
            e_total = e_induced + e_incoming;
            
            e_intensity = dot(e_total, e_total, 3);
            e0_intensity = dot(e_incoming, e_incoming, 3);
            enhancement = sqrt(e_intensity ./ e0_intensity);
            
            field_data(ipol).polarization = pol(ipol, :);
            field_data(ipol).wavelength = enei(ien);
            field_data(ipol).e_total = e_total;
            field_data(ipol).enhancement = enhancement;
            field_data(ipol).intensity = e_intensity;
            field_data(ipol).x_grid = x_grid;
            field_data(ipol).y_grid = y_grid;
            field_data(ipol).z_grid = z_grid;
            
            field_calc_time = toc(field_calc_start);
            fprintf('  → Field calculation completed in %.2f seconds\\n', field_calc_time);
        end
"""
        
        return code
    
    def _generate_save_results(self):
        """Generate code to save simulation results."""
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = """
%% Save Results
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Saving results...\\n');

results = struct();
results.wavelength = enei;
results.scattering = sca;
results.extinction = ext;
results.absorption = abs_cross;
results.polarizations = pol;
results.propagation_dirs = dir;
results.calculation_time = calculation_time;
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    results.fields = field_data;
    fprintf('Field data included in results\\n');
end
"""
        
        code += """
save('simulation_results.mat', 'results');
fprintf('✓ Results saved to: simulation_results.mat\\n');

% Save cross sections to text file
fid = fopen('simulation_results.txt', 'w');
fprintf(fid, 'Wavelength(nm)\\t');
for ipol = 1:n_polarizations
    fprintf(fid, 'Sca_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    fprintf(fid, 'Ext_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    if ipol < n_polarizations
        fprintf(fid, 'Abs_pol%d\\t', ipol);
    else
        fprintf(fid, 'Abs_pol%d', ipol);
    end
end
fprintf(fid, '\\n');

for i = 1:length(enei)
    fprintf(fid, '%.2f\\t', enei(i));
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', sca(i, ipol));
    end
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', ext(i, ipol));
    end
    for ipol = 1:n_polarizations
        if ipol < n_polarizations
            fprintf(fid, '%.6e\\t', abs_cross(i, ipol));
        else
            fprintf(fid, '%.6e', abs_cross(i, ipol));
        end
    end
    fprintf(fid, '\\n');
end
fclose(fid);
fprintf('✓ Cross sections saved to: simulation_results.txt\\n');
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    save('field_data.mat', 'field_data', '-v7.3');
    fprintf('✓ Field data saved to: field_data.mat\\n');
end
"""
        
        code += """
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_footer(self):
        """
        Generate safe cleanup and exit code.
        
        IMPROVEMENTS:
        1. Safer parallel pool cleanup
        2. Longer pause before quit (5 seconds instead of 3)
        3. Force file sync
        4. FIXED: Use 'exit' instead of invalid 'quit force'
        """
        use_parallel = self.config.get('use_parallel', False)
        
        code = """
%% Cleanup and Exit
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Cleaning up...\\n');

"""

        # Add parallel cleanup if parallel was enabled
        if use_parallel:
            code += self._generate_parallel_cleanup()
        
        code += """
% Close all waitbars
try
    multiWaitbar('CloseAll');
    fprintf('  ✓ Closed all waitbars\\n');
catch
    % multiWaitbar not used or already closed
end

% Close all figures
close all;
fprintf('  ✓ Closed all figures\\n');

% Clear large variables to free memory
clear bem sig field_data meshfield e_induced e_incoming e_total enhancement;
fprintf('  ✓ Cleared temporary variables\\n');

% CRITICAL: Close all file handles AND force sync to disk
fclose('all');
fprintf('  ✓ Closed all file handles\\n');

% Verify important files were written
if exist('field_data.mat', 'file')
    fprintf('  → Verifying field_data.mat...\\n');
    file_info = dir('field_data.mat');
    fprintf('    File size: %.2f MB\\n', file_info.bytes / 1024 / 1024);
end

fprintf('================================================================\\n');
fprintf('\\n');
fprintf('=== MNPBEM Simulation Completed Successfully ===\\n');
fprintf('\\n');

%% Safe Exit Sequence
fprintf('Preparing to exit MATLAB...\\n');

% IMPROVED: Longer pause for I/O completion (5 seconds instead of 3)
fprintf('  Waiting for all I/O operations to complete...\\n');
pause(5);

% Turn off diary if it was on
try
    diary off;
catch
    % Ignore if diary wasn't on
end

% Safe exit
fprintf('Exiting MATLAB now.\\n');
fprintf('\\n');

% FIXED: Use 'exit' instead of invalid 'quit force'
exit;
"""
        return code
    
    def _python_list_to_matlab(self, python_list):
        """Convert Python list to MATLAB array string."""
        if not python_list:
            return '[]'
        
        if isinstance(python_list[0], (list, tuple)):
            rows = []
            for row in python_list:
                row_str = ', '.join([str(x) for x in row])
                rows.append(row_str)
            return '[' + '; '.join(rows) + ']'
        else:
            return '[' + ', '.join([str(x) for x in python_list]) + ']'

    def _extract_closed_args(self, material_code):
        """Extract closed arguments from material code."""
        # Find: closed = [1, 2];
        if 'closed = [' in material_code:
            start = material_code.find('closed = [') + len('closed = [')
            end = material_code.find(']', start)
            self._closed_args = material_code[start:end].strip()
        else:
            # Single value: closed = 1;
            if 'closed = ' in material_code:
                start = material_code.find('closed = ') + len('closed = ')
                end = material_code.find(';', start)
                self._closed_args = material_code[start:end].strip()
            else:
                self._closed_args = "1"

    def _generate_wavelength_loop_with_chunking(self):
        """
        Wavelength loop with memory-efficient chunking AND field calculation support.
        
        Strategy: 
        1. Calculate ALL cross sections first (no field in loop)
        2. Find peak AFTER all chunks complete
        3. Calculate field separately for peak wavelength
        """
        
        wavelength_range = self.config['wavelength_range']
        chunk_size = self.config.get('wavelength_chunk_size', 20)
        use_parallel = self.config.get('use_parallel', False)
        excitation_type = self.config['excitation_type']
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = f"""
%% Wavelength Loop with Chunking (Memory-Efficient!)
if ~exist('enei', 'var')
    enei = linspace({wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]});
end

n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

% Chunking setup
chunk_size = {chunk_size};
n_chunks = ceil(n_wavelengths / chunk_size);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('     Starting BEM Calculation with Wavelength Chunking         \\n');
fprintf('================================================================\\n');
fprintf('Total wavelengths: %d\\n', n_wavelengths);
fprintf('Chunk size: %d wavelengths\\n', chunk_size);
fprintf('Number of chunks: %d\\n', n_chunks);
fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""

        if use_parallel:
            code += self._generate_parallel_setup()
        
        code += """
%% Initialize Excitation (once, outside all loops!)
fprintf('\\nInitializing excitation object...\\n');
"""

        if excitation_type == 'planewave':
            code += """exc = planewave(pol, dir, op);
fprintf('  ✓ Plane wave excitation initialized\\n');
"""
        elif excitation_type == 'dipole':
            code += """pt = compoint(p, dip_pos, op);
exc = dipole(pt, dip_mom, op);
fprintf('  ✓ Dipole excitation initialized\\n');
"""
        elif excitation_type == 'eels':
            code += """exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
fprintf('  ✓ EELS excitation initialized\\n');
"""
        
        code += """
% Start overall timer
total_start = tic;

%% ========================================
%% CHUNK LOOP: Calculate cross sections ONLY (NO field calculation)
%% ========================================
for ichunk = 1:n_chunks
    % Calculate wavelength indices for this chunk
    idx_start = (ichunk-1) * chunk_size + 1;
    idx_end = min(ichunk * chunk_size, n_wavelengths);
    chunk_indices = idx_start:idx_end;
    n_chunk = length(chunk_indices);
    
    fprintf('\\n');
    fprintf('================================================================\\n');
    fprintf('  Processing Chunk %d/%d: wavelengths %d-%d (%d points)\\n', ...
            ichunk, n_chunks, idx_start, idx_end, n_chunk);
    fprintf('  λ range: %.1f - %.1f nm\\n', ...
            enei(idx_start), enei(idx_end));
    fprintf('================================================================\\n');
    
    chunk_start = tic;
    
    % CRITICAL: Clear BEM solver between chunks!
    if ichunk > 1
        fprintf('  → Clearing BEM memory from previous chunk...\\n');
        bem = clear(bem);
        fprintf('  ✓ Memory cleared\\n');
    end
    
"""

        if use_parallel:
            code += """    % Parallel/Serial processing within chunk
    if exist('parallel_enabled', 'var') && parallel_enabled
        fprintf('  Using parallel execution for this chunk\\n\\n');
        
        parfor i_local = 1:n_chunk
            ien = chunk_indices(i_local);
            
            try
                % Progress
                if mod(i_local-1, max(1, floor(n_chunk/5))) == 0
                    fprintf('    [Worker] λ %d/%d (%.1f nm)\\n', ...
                            i_local, n_chunk, enei(ien));
                end
                
                % BEM calculation (cross sections only)
                sig = bem \\ exc(p, enei(ien));
                
                % Store results
                sca(ien, :) = exc.sca(sig);
                ext(ien, :) = exc.ext(sig);
                abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
                
            catch ME
                fprintf('    ERROR at λ %d (%.1f nm): %s\\n', ...
                        ien, enei(ien), ME.message);
                sca(ien, :) = zeros(1, n_polarizations);
                ext(ien, :) = zeros(1, n_polarizations);
                abs_cross(ien, :) = zeros(1, n_polarizations);
            end
        end
        
    else
        fprintf('  Using serial execution for this chunk\\n\\n');
        
        for i_local = 1:n_chunk
            ien = chunk_indices(i_local);
            
            % Progress
            if mod(i_local-1, max(1, floor(n_chunk/10))) == 0
                fprintf('    Progress: %d/%d (λ = %.1f nm)\\n', ...
                        i_local, n_chunk, enei(ien));
            end
            
            try
                % BEM calculation (cross sections only)
                sig = bem \\ exc(p, enei(ien));
                
                % Store results
                sca(ien, :) = exc.sca(sig);
                ext(ien, :) = exc.ext(sig);
                abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
                
            catch ME
                fprintf('    ERROR at λ %d (%.1f nm): %s\\n', ...
                        ien, enei(ien), ME.message);
                sca(ien, :) = zeros(1, n_polarizations);
                ext(ien, :) = zeros(1, n_polarizations);
                abs_cross(ien, :) = zeros(1, n_polarizations);
            end
        end
    end
"""
        else:
            # Serial only
            code += """    % Serial processing within chunk
    fprintf('  Using serial execution for this chunk\\n\\n');
    
    for i_local = 1:n_chunk
        ien = chunk_indices(i_local);
        
        % Progress
        if mod(i_local-1, max(1, floor(n_chunk/10))) == 0
            fprintf('    Progress: %d/%d (λ = %.1f nm)\\n', ...
                    i_local, n_chunk, enei(ien));
        end
        
        try
            % BEM calculation (cross sections only)
            sig = bem \\ exc(p, enei(ien));
            
            % Store results
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            fprintf('    ERROR at λ %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
    end
"""
        
        # Chunk timing
        code += """    
    chunk_time = toc(chunk_start);
    fprintf('\\n  ✓ Chunk %d completed in %.1f seconds (%.1f min)\\n', ...
            ichunk, chunk_time, chunk_time/60);
    fprintf('  Average: %.2f sec/wavelength\\n', chunk_time/n_chunk);
    
    % Force garbage collection between chunks
    pause(1);
end

% Total timing for cross sections
total_time = toc(total_start);
calculation_time = total_time;
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('ALL CHUNKS COMPLETED\\n');
fprintf('Total time: %.1f seconds (%.1f minutes)\\n', total_time, total_time/60);
fprintf('Average: %.2f seconds/wavelength\\n', total_time/n_wavelengths);
fprintf('================================================================\\n');
"""

        # ✅ CRITICAL: Field calculation AFTER all chunks complete
        if calculate_fields:
            code += """
%% ========================================
%% FIELD CALCULATION (After all chunks complete)
%% ========================================
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('           Field Calculation at Peak Wavelength                \\n');
fprintf('================================================================\\n');
"""
            
            # Determine peak wavelength
            field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
            
            if field_wl_idx == 'middle':
                code += """
% Use middle wavelength
field_wavelength_idx = round(n_wavelengths / 2);
fprintf('Using middle wavelength: λ = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif field_wl_idx == 'peak':
                code += """
% Find absorption peak wavelength
fprintf('Finding absorption peak...\\n');
abs_avg = mean(abs_cross, 2);
[max_abs, field_wavelength_idx] = max(abs_avg);
fprintf('  ✓ Peak absorption: %.2e nm² at λ = %.1f nm (index %d)\\n', ...
        max_abs, enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif field_wl_idx == 'peak_ext':
                code += """
% Find extinction peak wavelength
fprintf('Finding extinction peak...\\n');
ext_avg = mean(ext, 2);
[max_ext, field_wavelength_idx] = max(ext_avg);
fprintf('  ✓ Peak extinction: %.2e nm² at λ = %.1f nm (index %d)\\n', ...
        max_ext, enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif field_wl_idx == 'peak_sca':
                code += """
% Find scattering peak wavelength
fprintf('Finding scattering peak...\\n');
sca_avg = mean(sca, 2);
[max_sca, field_wavelength_idx] = max(sca_avg);
fprintf('  ✓ Peak scattering: %.2e nm² at λ = %.1f nm (index %d)\\n', ...
        max_sca, enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif isinstance(field_wl_idx, int):
                code += f"""
% Use specified wavelength index
field_wavelength_idx = {field_wl_idx};
fprintf('Using specified wavelength: λ = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            else:
                code += """
% Default: use middle wavelength
field_wavelength_idx = round(n_wavelengths / 2);
fprintf('Using middle wavelength: λ = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            
            # Create field mesh
            use_substrate = self.config.get('use_substrate', False)
            
            if use_substrate:
                mindist = self.config.get('field_mindist', 0.5)
                nmax = self.config.get('field_nmax', 2000)
                code += f"""
% Create meshfield (substrate mode with greentab)
fprintf('\\nCreating meshfield for substrate...\\n');
x_grid = reshape(x_grid, grid_shape);
y_grid = reshape(y_grid, grid_shape);
z_grid = reshape(z_grid, grid_shape);

emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', {mindist}, 'nmax', {nmax});
fprintf('  ✓ Meshfield ready: %d points\\n', emesh.pt.n);
"""
            else:
                field_region = self.config.get('field_region', {})
                mindist = self.config.get('field_mindist', 0.2)
                nmax = self.config.get('field_nmax', 2000)
                x_range = field_region.get('x_range', [-50, 50, 101])
                y_range = field_region.get('y_range', [0, 0, 1])
                z_range = field_region.get('z_range', [0, 0, 1])
                
                code += """
% Create meshfield
fprintf('\\nCreating field grid...\\n');
"""
                
                if y_range[2] == 1:  # xz-plane
                    code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
                elif z_range[2] == 1:  # xy-plane
                    code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
                
                code += f"""
emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', {mindist}, 'nmax', {nmax});
fprintf('  ✓ Meshfield created: %d points\\n', numel(x_grid));
"""
            
            # Calculate fields at peak wavelength
            code += """
% Initialize field data storage
field_data = struct();

% Calculate fields at peak wavelength
fprintf('\\nCalculating fields at λ = %.1f nm...\\n', enei(field_wavelength_idx));
field_calc_start = tic;

% Recalculate sig at peak wavelength
fprintf('  Computing BEM solution at peak wavelength...\\n');
sig_peak = bem \\ exc(p, enei(field_wavelength_idx));

% Calculate fields for ALL polarizations
for ipol = 1:n_polarizations
    fprintf('  Processing polarization %d/%d...\\n', ipol, n_polarizations);
    
    e_induced = emesh(sig_peak);
    e_incoming = emesh(exc.field(emesh.pt, enei(field_wavelength_idx)));
    e_total = e_induced + e_incoming;
    
    e_intensity = dot(e_total, e_total, 3);
    e0_intensity = dot(e_incoming, e_incoming, 3);
    enhancement = sqrt(e_intensity ./ e0_intensity);
    
    field_data(ipol).polarization = pol(ipol, :);
    field_data(ipol).wavelength = enei(field_wavelength_idx);
    field_data(ipol).e_total = e_total;
    field_data(ipol).enhancement = enhancement;
    field_data(ipol).intensity = e_intensity;
    field_data(ipol).x_grid = x_grid;
    field_data(ipol).y_grid = y_grid;
    field_data(ipol).z_grid = z_grid;
end

field_calc_time = toc(field_calc_start);
fprintf('\\n✓ Field calculation completed in %.2f seconds\\n', field_calc_time);
fprintf('================================================================\\n');

% Update total calculation time
calculation_time = calculation_time + field_calc_time;
"""
        
        return code

