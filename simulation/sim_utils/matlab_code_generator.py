"""
MATLAB Code Generator

Generates complete MATLAB simulation scripts with field calculation support.
Supports nonlocal quantum corrections for sub-nanometer gaps.
"""

import numpy as np
from .nonlocal_generator import NonlocalGenerator


class MatlabCodeGenerator:
    """Generates complete MATLAB simulation code."""
    
    def __init__(self, config, verbose=False):
        self.config = config
        self.verbose = verbose
        self.nonlocal_gen = NonlocalGenerator(config, verbose)
    
    def generate_complete_script(self, geometry_code, material_code):
        """Generate complete MATLAB simulation script."""
        
        # Header
        header = self._generate_header()
        
        # Options
        options = self._generate_options()
        
        # Geometry
        geometry = geometry_code
        
        # Materials
        materials = material_code
        
        # Comparticle creation
        comparticle = self._generate_comparticle()
        
        # Validation (if nonlocal)
        validation = self._validate_nonlocal_setup()
        
        # BEM solver
        bem_solver = self._generate_bem_solver()
        
        # Excitation
        excitation = self._generate_excitation()
        
        # Wavelength loop
        wavelength_loop = self._generate_wavelength_loop()
        
        # Save results
        save_results = self._generate_save_results()
        
        # Footer
        footer = self._generate_footer()
        
        # Combine all parts
        complete_code = f"""{header}

{options}

{geometry}

{materials}

{comparticle}

{validation}

{bem_solver}

{excitation}

{wavelength_loop}

{save_results}

{footer}
"""
        return complete_code
    
    def _generate_header(self):
        """Generate script header."""
        code = """% MNPBEM Simulation Script
% Auto-generated by MNPBEM Automation Pipeline
%
% DO NOT EDIT THIS FILE MANUALLY
% Modify the configuration file instead and regenerate

clear all;
close all;
clc;

fprintf('=== MNPBEM Simulation Started ===\\n');
fprintf('Structure: %s\\n', '{structure}');
fprintf('Simulation Type: %s\\n', '{sim_type}');
""".format(
            structure=self.config['structure'],
            sim_type=self.config['simulation_type']
        )
        return code
    
    def _generate_options(self):
        """Generate BEM options with proper settings."""
        sim_type = self.config['simulation_type']
        use_mirror = self.config.get('use_mirror_symmetry', False)
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        
        refine = self.config.get('refine', 3 if use_nonlocal else 1)
        relcutoff = self.config.get('relcutoff', 2 if use_iterative else 3)
        
        code = f"""
%% BEM Options
fprintf('\\nSetting up BEM options...\\n');
"""
        
        # Base options
        if sim_type == 'stat':
            code += "op = bemoptions( 'sim', 'stat', 'interp', 'curv' );\n"
        else:
            code += "op = bemoptions( 'sim', 'ret', 'interp', 'curv' );\n"
        
        code += f"op.refine = {refine};\n"
        
        # Mirror symmetry
        if use_mirror:
            if isinstance(use_mirror, str):
                sym = use_mirror
            else:
                sym = 'xy'
            code += f"op.sym = '{sym}';\n"
            code += f"fprintf('  ✓ Mirror symmetry: {sym}\\n');\n"
        
        # Nonlocal options (high precision integration)
        if use_nonlocal:
            nonlocal_opts = self.nonlocal_gen.generate_bem_options()
            code += nonlocal_opts
        
        # Iterative solver options
        if use_iterative:
            code += f"""
%% Iterative Solver Options
relcutoff = {relcutoff};
fprintf('  ✓ Iterative solver: relcutoff=%d\\n', relcutoff);
"""
        
        code += "\nfprintf('✓ BEM options configured\\n');\n"
        
        return code
    
    def _generate_comparticle(self):
        """Generate comparticle object creation with visualization."""
        code = f"""
%% Create Comparticle Object
fprintf('\\nCreating comparticle object...\\n');
p = comparticle(epstab, particles, inout, closed, op);
fprintf('Comparticle created with %d boundary elements\\n', p.n);

%% Visualize and Save Structure
fprintf('\\nGenerating structure visualizations...\\n');

try
    n_particles = length(particles);
    
    % Define colors
    core_color = [1.0, 0.7, 0.3];  % Gold/orange for core
    shell_color_1 = [0.7, 0.85, 1.0];  % Light blue
    shell_color_2 = [0.5, 0.7, 0.95];  % Medium blue
    shell_color_3 = [0.3, 0.5, 0.9];   % Darker blue
    
    % ========== 3D View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    % Check if single or multi-particle structure
    if n_particles == 1
        % Single particle: simple plot
        plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        % Multi-particle (core-shell): plot with progressive transparency
        for i = 1:n_particles
            if i == 1
                % Core: opaque, gold color
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', core_color, 'FaceAlpha', 1.0);
            else
                % Shells: progressively more transparent
                shell_idx = i - 1;
                
                % Select transparency and color
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    % General case
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', color, 'FaceAlpha', alpha);
            end
        end
        
        % Add legend for multi-layer structures
        legend_entries = cell(n_particles, 1);
        legend_entries{{1}} = 'Core';
        for i = 2:n_particles
            legend_entries{{i}} = sprintf('Shell %d', i-1);
        end
        legend(legend_entries, 'Location', 'northeast', 'FontSize', 10);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('3D View', 'FontSize', 14, 'FontWeight', 'bold');
    view(45, 30);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver3(0, 0, 0, arrow_len, 0, 0, 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, arrow_len, 0, 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, 0, arrow_len, 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 0, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0, 0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    axis equal;
    axis off;
    view(45, 30);
    xlim([-0.3, 1.5]);
    ylim([-0.3, 1.5]);
    zlim([-0.3, 1.5]);
    
    print('structure_3D.png', '-dpng', '-r300');
    fprintf('  ✓ 3D view saved\\n');
    close(fig);
    
    % ========== XY View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            if i == 1
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', color, 'FaceAlpha', alpha);
            end
        end
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('XY View (Top View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 90);
    grid on;
    box on;
    
    print('structure_XY.png', '-dpng', '-r300');
    fprintf('  ✓ XY view saved\\n');
    close(fig);
    
    % ========== YZ View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            if i == 1
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', color, 'FaceAlpha', alpha);
            end
        end
    end
    
    axis equal;
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('YZ View (Side View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 0);
    grid on;
    box on;
    
    print('structure_YZ.png', '-dpng', '-r300');
    fprintf('  ✓ YZ view saved\\n');
    close(fig);
    
    % ========== ZX View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot(p, 'EdgeColor', 'b', 'FaceColor', [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            if i == 1
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot(particles{{i}}, 'EdgeColor', 'none', ...
                     'FaceColor', color, 'FaceAlpha', alpha);
            end
        end
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('ZX View (Front View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(90, 0);
    grid on;
    box on;
    
    print('structure_ZX.png', '-dpng', '-r300');
    fprintf('  ✓ ZX view saved\\n');
    close(fig);
    
    fprintf('  ✓ All structure visualizations completed!\\n');
    
catch ME
    fprintf('  Warning: Could not save structure plots: %s\\n', ME.message);
end
"""
        return code
    
    def _validate_nonlocal_setup(self):
        """Validate that nonlocal setup is correct."""
        if not self.nonlocal_gen.is_needed():
            return ""
        
        code = """
%% Validate Nonlocal Setup
fprintf('\\n=== Validating Nonlocal Setup ===\\n');

% Check number of particles
n_particles = length(particles);
fprintf('  Number of particle boundaries: %d\\n', n_particles);

% Check epstab
n_materials = length(epstab);
fprintf('  Number of materials in epstab: %d\\n', n_materials);

% Check inout matrix
[n_boundaries, ~] = size(inout);
fprintf('  Number of boundaries in inout: %d\\n', n_boundaries);

% Validation
if n_particles ~= n_boundaries
    error('Mismatch: %d particles but %d boundaries in inout!', n_particles, n_boundaries);
end

fprintf('✓ Nonlocal setup validated\\n');
"""
        return code
    
    def _generate_bem_solver(self):
        """Generate BEM solver initialization code."""
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        
        code = """
%% Initialize BEM Solver
fprintf('\\nInitializing BEM solver...\\n');
"""
        
        if use_iterative:
            code += """
% Configure iterative solver options
fprintf('  Using iterative BEM solver (for large structures)\\n');
op.iter = bemiter.options( 'output', 1 );
op.iter.tol = 1e-4;
op.iter.maxit = 200;
op.iter.solver = 'gmres';
op.iter.cleaf = 200;
op.iter.htol = 1e-6;
op.iter.kmax = [4, 100];
op.iter.fadmiss = @(rad1,rad2,dist) 2.5 * min(rad1,rad2) < dist;

fprintf('  Iterative solver parameters:\\n');
fprintf('    - Solver: %s\\n', op.iter.solver);
fprintf('    - Tolerance: %g\\n', op.iter.tol);
fprintf('    - Max iterations: %d\\n', op.iter.maxit);
"""
        
        # Add nonlocal refinement if enabled
        if use_nonlocal:
            refine_code = self.nonlocal_gen.generate_refine_function('p')
            
            code += f"""
% Nonlocal refinement for cover layer boundaries
{refine_code}

% Initialize solver with refined integration function
"""
            if use_iterative:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('✓ Nonlocal BEM solver initialized (iterative)\\n');
"""
            else:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('✓ Nonlocal BEM solver initialized (direct)\\n');
"""
        else:
            # Standard BEM solver
            code += """
% Initialize BEM solver
try
    bem = bemsolver(p, op);
    fprintf('BEM solver initialized successfully\\n');
    fprintf('  - Boundary elements: %d\\n', size(p.pos, 1));
catch ME
    fprintf('Error initializing BEM solver: %s\\n', ME.message);
    rethrow(ME);
end
"""
        
        return code
    
    def _generate_excitation(self):
        """Generate excitation configuration."""
        excitation_type = self.config['excitation_type']
        
        if excitation_type == 'planewave':
            code = self._generate_planewave_excitation()
        elif excitation_type == 'dipole':
            code = self._generate_dipole_excitation()
        elif excitation_type == 'eels':
            code = self._generate_eels_excitation()
        else:
            raise ValueError(f"Unknown excitation type: {excitation_type}")
        
        return code
    
    def _generate_planewave_excitation(self):
        """Generate plane wave excitation code."""
        polarizations = self.config['polarizations']
        propagation_dirs = self.config['propagation_dirs']
        
        pol_str = self._python_list_to_matlab(polarizations)
        dir_str = self._python_list_to_matlab(propagation_dirs)
        
        code = f"""
%% Plane Wave Excitation
fprintf('\\nConfiguring plane wave excitation...\\n');

% Polarization vectors
pol = {pol_str};

% Propagation directions
dir = {dir_str};

fprintf('Number of polarizations: %d\\n', size(pol, 1));
fprintf('Number of propagation directions: %d\\n', size(dir, 1));
"""
        return code
    
    def _generate_dipole_excitation(self):
        """Generate dipole excitation code."""
        position = self.config.get('dipole_position', [0, 0, 15])
        moment = self.config.get('dipole_moment', [0, 0, 1])
        
        pos_str = self._python_list_to_matlab([position])
        mom_str = self._python_list_to_matlab([moment])
        
        code = f"""
%% Dipole Excitation
fprintf('\\nConfiguring dipole excitation...\\n');

% Dipole position
dip_pos = {pos_str};

% Dipole moment
dip_mom = {mom_str};

fprintf('Dipole position: [%.2f, %.2f, %.2f] nm\\n', dip_pos(1), dip_pos(2), dip_pos(3));
"""
        return code
    
    def _generate_eels_excitation(self):
        """Generate EELS excitation code."""
        impact = self.config.get('impact_parameter', [10, 0])
        energy = self.config.get('beam_energy', 200e3)
        width = self.config.get('beam_width', 0.2)
        
        code = f"""
%% EELS Excitation
fprintf('\\nConfiguring EELS excitation...\\n');

% Impact parameter
impact = [{impact[0]}, {impact[1]}];

% Beam parameters
beam_energy = {energy};
beam_width = {width};

fprintf('Impact parameter: [%.2f, %.2f] nm\\n', impact(1), impact(2));
fprintf('Beam energy: %.2e eV\\n', beam_energy);
"""
        return code
    
    def _generate_wavelength_loop(self):
        """Generate wavelength loop with optional field calculation."""
        wavelength_range = self.config['wavelength_range']
        calculate_fields = self.config.get('calculate_fields', False)
        excitation_type = self.config['excitation_type']
        
        code = f"""
%% Wavelength Loop
wavelength_range = [{wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]}];
enei = linspace(wavelength_range(1), wavelength_range(2), wavelength_range(3));
n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('              Starting BEM Calculation\\n');
fprintf('================================================================\\n');
fprintf('Wavelength range: %.1f - %.1f nm\\n', wavelength_range(1), wavelength_range(2));
fprintf('Number of wavelengths: %d\\n', n_wavelengths);
fprintf('Number of polarizations: %d\\n', n_polarizations);
fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""
        
        if calculate_fields:
            code += self._generate_field_setup()
        
        code += """
% Start timer
calculation_start = tic;

% Loop over wavelengths
for ien = 1:n_wavelengths
    progress_pct = (ien-1) / n_wavelengths * 100;
    
    bar_length = 40;
    filled = floor(bar_length * (ien-1) / n_wavelengths);
    bar = ['[' repmat('=', 1, filled) repmat('.', 1, bar_length - filled) ']'];
    
    fprintf('\\r%s %.1f%% | λ = %.1f nm', bar, progress_pct, enei(ien));
    
    % Loop over polarizations
    for ipol = 1:n_polarizations
"""
        
        if excitation_type == 'planewave':
            code += """
        % Plane wave excitation
        exc = planewave(pol(ipol, :), dir(ipol, :), op);
"""
        elif excitation_type == 'dipole':
            code += """
        % Dipole excitation
        pt = compoint(p, dip_pos, op);
        dip = dipole(pt, dip_mom, op);
        exc = dip;
"""
        elif excitation_type == 'eels':
            code += """
        % EELS excitation
        exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
"""
        
        code += """
        % Solve BEM equation
        sig = bem \\ exc(p, enei(ien));
        
        % Calculate cross sections
        sca(ien, ipol) = exc.sca(sig);
        ext(ien, ipol) = exc.ext(sig);
        abs_cross(ien, ipol) = ext(ien, ipol) - sca(ien, ipol);
"""
        
        if calculate_fields:
            code += self._generate_field_calculation_in_loop()
        
        code += """
    end
end

% Complete progress bar
fprintf('\\r[');
fprintf(repmat('=', 1, 40));
fprintf('] 100.0%%\\n');

calculation_time = toc(calculation_start);
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Calculation completed in %.2f seconds (%.2f minutes)\\n', calculation_time, calculation_time/60);
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_field_setup(self):
        """Generate field mesh setup code."""
        field_region = self.config.get('field_region', {})
        mindist = self.config.get('field_mindist', 0.2)
        nmax = self.config.get('field_nmax', 2000)
        field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
        
        x_range = field_region.get('x_range', [-50, 50, 101])
        y_range = field_region.get('y_range', [0, 0, 1])
        z_range = field_region.get('z_range', [0, 0, 1])
        
        code = f"""
%% Field Calculation Setup
fprintf('\\nSetting up field calculation mesh...\\n');

"""
        
        if field_wl_idx == 'middle':
            code += "field_wavelength_idx = round(n_wavelengths / 2);\n"
        elif field_wl_idx == 'peak':
            code += "field_wavelength_idx = -1;  % To be determined\n"
        elif isinstance(field_wl_idx, int):
            code += f"field_wavelength_idx = {field_wl_idx};\n"
        else:
            code += "field_wavelength_idx = round(n_wavelengths / 2);\n"
        
        code += "\nfprintf('Field will be calculated at wavelength index: %d\\n', field_wavelength_idx);\n\n"
        
        if y_range[2] == 1:  # xz-plane
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} + 0 * x_grid;
fprintf('Field mesh: xz-plane (y=%.1f), %dx%d points\\n', {y_range[0]}, length(x_field), length(z_field));
"""
        elif z_range[2] == 1:  # xy-plane
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} + 0 * x_grid;
fprintf('Field mesh: xy-plane (z=%.1f), %dx%d points\\n', {z_range[0]}, length(x_field), length(y_field));
"""
        else:  # 3D volume
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, y_grid, z_grid] = meshgrid(x_field, y_field, z_field);
fprintf('Field mesh: 3D volume, %dx%dx%d points\\n', length(x_field), length(y_field), length(z_field));
"""
        
        code += f"""
fprintf('Initializing meshfield object...\\n');
emesh = meshfield(p, x_grid, y_grid, z_grid, op, 'mindist', {mindist}, 'nmax', {nmax});
fprintf('  - Minimum distance: {mindist} nm\\n');
fprintf('  - Total field points: %d\\n', numel(x_grid));

field_data = struct();
"""
        
        return code
    
    def _generate_field_calculation_in_loop(self):
        """Generate field calculation code inside wavelength loop."""
        code = """
        % Calculate fields at selected wavelength
        if ien == field_wavelength_idx
            fprintf('\\n  → Calculating fields at λ = %.1f nm...\\n', enei(ien));
            field_calc_start = tic;
            
            e_induced = emesh(sig);
            e_incoming = emesh(exc.field(emesh.pt, enei(ien)));
            e_total = e_induced + e_incoming;
            
            e_intensity = dot(e_total, e_total, 3);
            e0_intensity = dot(e_incoming, e_incoming, 3);
            enhancement = sqrt(e_intensity ./ e0_intensity);
            
            field_data(ipol).polarization = pol(ipol, :);
            field_data(ipol).wavelength = enei(ien);
            field_data(ipol).e_total = e_total;
            field_data(ipol).enhancement = enhancement;
            field_data(ipol).intensity = e_intensity;
            field_data(ipol).x_grid = x_grid;
            field_data(ipol).y_grid = y_grid;
            field_data(ipol).z_grid = z_grid;
            
            field_calc_time = toc(field_calc_start);
            fprintf('  → Field calculation completed in %.2f seconds\\n', field_calc_time);
        end
"""
        return code
    
    def _generate_save_results(self):
        """Generate code to save simulation results."""
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = """
%% Save Results
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Saving results...\\n');

results = struct();
results.wavelength = enei;
results.scattering = sca;
results.extinction = ext;
results.absorption = abs_cross;
results.polarizations = pol;
results.propagation_dirs = dir;
results.calculation_time = calculation_time;
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    results.fields = field_data;
    fprintf('Field data included in results\\n');
end
"""
        
        code += """
save('simulation_results.mat', 'results');
fprintf('✓ Results saved to: simulation_results.mat\\n');

% Save cross sections to text file
fid = fopen('simulation_results.txt', 'w');
fprintf(fid, 'Wavelength(nm)\\t');
for ipol = 1:n_polarizations
    fprintf(fid, 'Sca_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    fprintf(fid, 'Ext_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    if ipol < n_polarizations
        fprintf(fid, 'Abs_pol%d\\t', ipol);
    else
        fprintf(fid, 'Abs_pol%d', ipol);
    end
end
fprintf(fid, '\\n');

for i = 1:length(enei)
    fprintf(fid, '%.2f\\t', enei(i));
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', sca(i, ipol));
    end
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', ext(i, ipol));
    end
    for ipol = 1:n_polarizations
        if ipol < n_polarizations
            fprintf(fid, '%.6e\\t', abs_cross(i, ipol));
        else
            fprintf(fid, '%.6e', abs_cross(i, ipol));
        end
    end
    fprintf(fid, '\\n');
end
fclose(fid);
fprintf('✓ Cross sections saved to: simulation_results.txt\\n');
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    save('field_data.mat', 'field_data', '-v7.3');
    fprintf('✓ Field data saved to: field_data.mat\\n');
end
"""
        
        code += """
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_footer(self):
        """Generate script footer with proper cleanup and exit."""
        code = """
%% Cleanup and Exit
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Cleaning up...\\n');

% Close all waitbars
try
    multiWaitbar('CloseAll');
    fprintf('  ✓ Closed all waitbars\\n');
catch
    % multiWaitbar not used or already closed
end

% Close all figures
close all;
fprintf('  ✓ Closed all figures\\n');

% Clear large variables to free memory
clear bem sig field_data meshfield;
fprintf('  ✓ Cleared temporary variables\\n');

fprintf('================================================================\\n');
fprintf('\\n');
fprintf('=== MNPBEM Simulation Completed Successfully ===\\n');
fprintf('\\n');

%% Exit MATLAB
exit;
"""
        return code
    
    def _python_list_to_matlab(self, python_list):
        """Convert Python list to MATLAB array string."""
        if not python_list:
            return '[]'
        
        if isinstance(python_list[0], (list, tuple)):
            rows = []
            for row in python_list:
                row_str = ', '.join([str(x) for x in row])
                rows.append(row_str)
            return '[' + '; '.join(rows) + ']'
        else:
            return '[' + ', '.join([str(x) for x in python_list]) + ']'