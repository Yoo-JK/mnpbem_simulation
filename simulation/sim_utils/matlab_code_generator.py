"""
MATLAB Code Generator

Generates complete MATLAB simulation scripts with field calculation support.
Supports nonlocal quantum corrections for sub-nanometer gaps.
Supports parallel computing with parfor (single node, multiple cores).
"""
import os
import numpy as np
from .nonlocal_generator import NonlocalGenerator


class MatlabCodeGenerator:
    """Generates complete MATLAB simulation code."""
    
    def __init__(self, config, verbose=False):
        self.config = config
        self.verbose = verbose
        self.nonlocal_gen = NonlocalGenerator(config, verbose)
    
    def generate_complete_script(self, geometry_code, material_code):
        """Generate complete MATLAB simulation script."""

        self._extract_closed_args(material_code)
        
        # Header
        header = self._generate_header()
        
        # Options
        options = self._generate_options()
        
        # Geometry
        geometry = geometry_code
        
        # Materials
        materials = material_code
        
        # Comparticle creation
        comparticle = self._generate_comparticle()
        
        # Validation (if nonlocal)
        validation = self._validate_nonlocal_setup()

        # Green function tabulation
        greentab = self._generate_substrate_greentab()
        
        # BEM solver
        bem_solver = self._generate_bem_solver()
        
        # Excitation
        excitation = self._generate_excitation()
        
        # Wavelength loop (now with parallel support!)
        wavelength_loop = self._generate_wavelength_loop()
        
        # Save results
        save_results = self._generate_save_results()
        
        # Footer (now with parallel cleanup!)
        footer = self._generate_footer()
        
        # Combine all parts
        complete_code = f"""{header}

{options}

{geometry}

{materials}

{comparticle}

{validation}

{greentab}

{bem_solver}

{excitation}

{wavelength_loop}

{save_results}

{footer}
"""
        return complete_code
    
    def _generate_header(self):
        """Generate script header."""
        code = """% MNPBEM Simulation Script
% Auto-generated by MNPBEM Automation Pipeline
%
% DO NOT EDIT THIS FILE MANUALLY
% Modify the configuration file instead and regenerate

clear all;
close all;
clc;

fprintf('=== MNPBEM Simulation Started ===\\n');
fprintf('Structure: %s\\n', '{structure}');
fprintf('Simulation Type: %s\\n', '{sim_type}');
""".format(
            structure=self.config['structure'],
            sim_type=self.config['simulation_type']
        )
        return code
    
    def _generate_options(self):
        """Generate BEM options with proper settings."""
        sim_type = self.config['simulation_type']
        use_mirror = self.config.get('use_mirror_symmetry', False)
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        use_substrate = self.config.get('use_substrate', False)

        if use_substrate and sim_type != 'ret':
            raise ValueError(
                "Substrate simulations require 'ret' (retarded) simulation type. "
                f"Current simulation_type is '{sim_type}'. "
                "Please set: args['simulation_type'] = 'ret'"
            )
        
        refine = self.config.get('refine', 3 if use_nonlocal else 1)
        relcutoff = self.config.get('relcutoff', 2 if use_iterative else 3)
        
        code = f"""
%% BEM Options
fprintf('\\nSetting up BEM options...\\n');
"""
        
        # Base options
        if sim_type == 'stat':
            code += "op = bemoptions( 'sim', 'stat', 'interp', 'curv' );\n"
        else:
            code += "op = bemoptions( 'sim', 'ret', 'interp', 'curv' );\n"
        
        code += f"op.refine = {refine};\n"

        if use_substrate:
            code += """
fprintf('  ✓ Substrate mode enabled\\n');
fprintf('  ⚠ Green function tabulation will be required\\n');
"""
        
        # Mirror symmetry
        if use_mirror:
            if isinstance(use_mirror, str):
                sym = use_mirror
            else:
                sym = 'xy'
            code += f"op.sym = '{sym}';\n"
            code += f"fprintf('  ✓ Mirror symmetry: {sym}\\n');\n"
        
        # Nonlocal options (high precision integration)
        if use_nonlocal:
            nonlocal_opts = self.nonlocal_gen.generate_bem_options()
            code += nonlocal_opts
        
        # Iterative solver options
        if use_iterative:
            code += f"""
%% Iterative Solver Options
relcutoff = {relcutoff};
fprintf('  ✓ Iterative solver: relcutoff=%d\\n', relcutoff);
"""
        
        code += "\nfprintf('✓ BEM options configured\\n');\n"
        
        return code
    
    def _generate_parallel_setup(self):
        """Generate parallel pool setup code."""
        num_workers = self.config.get('num_workers', 'auto')
        
        code = """
%% Parallel Computing Setup
fprintf('\\n=== Setting up Parallel Computing ===\\n');

"""
        
        # Determine number of workers based on config
        if num_workers == 'env':
            code += """% Get number of workers from environment variable
if ~isempty(getenv('MNPBEM_NUM_WORKERS'))
    requested_workers = str2double(getenv('MNPBEM_NUM_WORKERS'));
    fprintf('Reading from environment: MNPBEM_NUM_WORKERS=%d\\n', requested_workers);
elseif ~isempty(getenv('SLURM_CPUS_PER_TASK'))
    requested_workers = str2double(getenv('SLURM_CPUS_PER_TASK'));
    fprintf('Detected Slurm environment: SLURM_CPUS_PER_TASK=%d\\n', requested_workers);
else
    requested_workers = feature('numcores');
    fprintf('Auto-detected available cores: %d\\n', requested_workers);
end
"""
        elif num_workers == 'auto':
            code += """% Auto-detect available cores
requested_workers = feature('numcores');
fprintf('Auto-detected available cores: %d\\n', requested_workers);
"""
        elif isinstance(num_workers, int):
            code += f"""% Using specified number of workers
requested_workers = {num_workers};
fprintf('Using specified workers: %d\\n', requested_workers);
"""
        else:
            code += """% Default to 1 worker (serial)
requested_workers = 1;
fprintf('Using default: 1 worker (serial execution)\\n');
"""
        
        code += """
% Create parallel pool
try
    % Check if pool already exists
    existing_pool = gcp('nocreate');
    
    if isempty(existing_pool)
        % No existing pool, create new one
        if requested_workers > 1
            fprintf('Creating parallel pool with %d workers...\\n', requested_workers);
            pool = parpool('local', requested_workers);
            fprintf('✓ Parallel pool created successfully: %d workers\\n', pool.NumWorkers);
            parallel_enabled = true;
        else
            fprintf('Serial execution mode (1 worker)\\n');
            pool = [];
            parallel_enabled = false;
        end
    else
        % Pool exists, use it
        pool = existing_pool;
        fprintf('✓ Using existing parallel pool: %d workers\\n', pool.NumWorkers);
        parallel_enabled = true;
    end
    
catch ME
    fprintf('⚠ Warning: Failed to create parallel pool\\n');
    fprintf('Error: %s\\n', ME.message);
    fprintf('Continuing with serial execution...\\n');
    pool = [];
    parallel_enabled = false;
end

fprintf('=== Parallel Setup Complete ===\\n\\n');
"""
        return code
    
    def _generate_parallel_cleanup(self):
        """Generate parallel pool cleanup code."""
        code = """
%% Parallel Computing Cleanup
if exist('parallel_enabled', 'var') && parallel_enabled && ~isempty(gcp('nocreate'))
    fprintf('\\nCleaning up parallel pool...\\n');
    delete(gcp('nocreate'));
    fprintf('✓ Parallel pool closed\\n');
end
"""
        return code
    
    def _generate_comparticle(self):
        """Generate comparticle object creation with visualization."""
        
        # Get closed indices from material manager
        closed_args = self._closed_args
        
        # Check if substrate is used
        use_substrate = self.config.get('use_substrate', False)

        if use_substrate:
            substrate = self.config.get('substrate', {})
            substrate_position = substrate.get('position', 0)
        
        code = """
%% Create Comparticle Object
fprintf('\\nCreating comparticle object...\\n');
p = comparticle(epstab, particles, inout, """ + closed_args + """, op);
fprintf('Comparticle created with %d boundary elements\\n', p.n);

%% Visualize and Save Structure
fprintf('\\nGenerating structure visualizations...\\n');

try
    n_particles = length(particles);
    
    % Define colors
    core_color = [1.0, 0.7, 0.3];  % Gold/orange for core
    shell_color_1 = [0.7, 0.85, 1.0];  % Light blue
    shell_color_2 = [0.5, 0.7, 0.95];  % Medium blue
    shell_color_3 = [0.3, 0.5, 0.9];   % Darker blue
    substrate_color = [0.85, 0.85, 0.85];  % Light gray
    
"""
        
        # Add substrate parameters
        if use_substrate:
            code += f"""    % Substrate parameters
    has_substrate = true;
    z_substrate = {substrate_position};
"""
        else:
            code += """    % No substrate
    has_substrate = false;
"""
        
        code += """    
    % Get particle bounds for plotting
    x_lim = [min(p.pos(:,1)), max(p.pos(:,1))];
    y_lim = [min(p.pos(:,2)), max(p.pos(:,2))];
    z_lim = [min(p.pos(:,3)), max(p.pos(:,3))];
    
    % Expand limits for substrate visualization
    x_expand = (x_lim(2) - x_lim(1)) * 0.3;
    y_expand = (y_lim(2) - y_lim(1)) * 0.3;
    x_range = [x_lim(1) - x_expand, x_lim(2) + x_expand];
    y_range = [y_lim(1) - y_expand, y_lim(2) + y_expand];
    
    % ========== 3D View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    % Check if single or multi-particle structure
    if n_particles == 1
        % Single particle: simple plot
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        % Multi-particle (core-shell): plot with progressive transparency
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                % Core: opaque, gold color
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                % Shells: progressively more transparent
                shell_idx = i - 1;
                
                % Select transparency and color
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    % General case
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
        
        % Add legend for multi-layer structures
        legend_entries = cell(n_particles, 1);
        legend_entries{1} = 'Core';
        for i = 2:n_particles
            legend_entries{i} = sprintf('Shell %d', i-1);
        end
        legend(legend_entries, 'Location', 'northeast', 'FontSize', 10);
    end
    
    % Draw substrate interface (3D view)
    if has_substrate
        % Create substrate plane
        [X_sub, Y_sub] = meshgrid(x_range, y_range);
        Z_sub = ones(size(X_sub)) * z_substrate;
        surf(X_sub, Y_sub, Z_sub, 'FaceColor', substrate_color, ...
             'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Draw interface outline
        plot3([x_range(1), x_range(2), x_range(2), x_range(1), x_range(1)], ...
              [y_range(1), y_range(1), y_range(2), y_range(2), y_range(1)], ...
              [z_substrate, z_substrate, z_substrate, z_substrate, z_substrate], ...
              'k-', 'LineWidth', 2);
        
        % Add label
        text(x_range(2)*0.8, y_range(2)*0.8, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('3D View', 'FontSize', 14, 'FontWeight', 'bold');
    view(45, 30);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver3(0, 0, 0, arrow_len, 0, 0, 'Color', 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, arrow_len, 0, 'Color', 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, 0, arrow_len, 'Color', 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 0, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0, 0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    axis equal;
    axis off;
    view(45, 30);
    xlim([-0.3, 1.5]);
    ylim([-0.3, 1.5]);
    zlim([-0.3, 1.5]);
    
    print('structure_3D.png', '-dpng', '-r300');
    fprintf('  ✓ 3D view saved\\n');
    close(fig);
    
    % ========== XY View (Top View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Substrate outline in XY view
    if has_substrate
        rectangle('Position', [x_range(1), y_range(1), ...
                              x_range(2)-x_range(1), y_range(2)-y_range(1)], ...
                 'EdgeColor', 'k', 'LineWidth', 2, 'LineStyle', '--');
        text(x_range(2)*0.85, y_range(2)*0.85, ...
             sprintf('Substrate z=%.1f', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k');
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('XY View (Top View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 90);
    grid on;
    box on;
    
    print('structure_XY.png', '-dpng', '-r300');
    fprintf('  ✓ XY view saved\\n');
    close(fig);
    
    % ========== YZ View (Side View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (YZ view - IMPORTANT!)
    if has_substrate
        plot3([y_range(1), y_range(2)], ...
              [z_substrate, z_substrate], ...
              [0, 0], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        y_fill = [y_range(1), y_range(2), y_range(2), y_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(y_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator
            y_mid = mean(y_range);
            plot3([y_mid, y_mid], [particle_bottom, z_substrate], [0, 0], ...
                  'r-', 'LineWidth', 2);
            text(y_mid, (particle_bottom + z_substrate)/2, 0, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(y_range(2)*0.85, z_substrate, 0, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('YZ View (Side View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 0);
    grid on;
    box on;
    
    print('structure_YZ.png', '-dpng', '-r300');
    fprintf('  ✓ YZ view saved\\n');
    close(fig);
    
    % ========== ZX View (Front View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (ZX view - IMPORTANT!)
    if has_substrate
        plot3([x_range(1), x_range(2)], ...
              [z_substrate, z_substrate], ...
              [0, 0], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        x_fill = [x_range(1), x_range(2), x_range(2), x_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(x_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator
            x_mid = mean(x_range);
            plot3([x_mid, x_mid], [particle_bottom, z_substrate], [0, 0], ...
                  'r-', 'LineWidth', 2);
            text(x_mid, (particle_bottom + z_substrate)/2, 0, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(x_range(2)*0.85, z_substrate, 0, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('ZX View (Front View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(90, 0);
    grid on;
    box on;
    
    print('structure_ZX.png', '-dpng', '-r300');
    fprintf('  ✓ ZX view saved\\n');
    close(fig);
    
    fprintf('  ✓ All structure visualizations completed!\\n');
    
catch ME
    fprintf('  Warning: Could not save structure plots: %s\\n', ME.message);
end
"""

        return code
    
    def _validate_nonlocal_setup(self):
        """Validate that nonlocal setup is correct."""
        if not self.nonlocal_gen.is_needed():
            return ""
        
        code = """
%% Validate Nonlocal Setup
fprintf('\\n=== Validating Nonlocal Setup ===\\n');

% Check number of particles
n_particles = length(particles);
fprintf('  Number of particle boundaries: %d\\n', n_particles);

% Check epstab
n_materials = length(epstab);
fprintf('  Number of materials in epstab: %d\\n', n_materials);

% Check inout matrix
[n_boundaries, ~] = size(inout);
fprintf('  Number of boundaries in inout: %d\\n', n_boundaries);

% Validation
if n_particles ~= n_boundaries
    error('Mismatch: %d particles but %d boundaries in inout!', n_particles, n_boundaries);
end

fprintf('✓ Nonlocal setup validated\\n');
"""
        return code

    def _generate_substrate_greentab(self):
        """
        Generate Green function tabulation code for substrate simulations.
        REQUIRED when using substrate with 'ret' simulation type.
        """
        use_substrate = self.config.get('use_substrate', False)
        sim_type = self.config['simulation_type']
        
        # Only needed for retarded simulations with substrate
        if not (use_substrate and sim_type == 'ret'):
            return ""
        
        # Get tabulation parameters
        nz = self.config.get('greentab_nz', 20)
        scale = self.config.get('greentab_scale', 1.0)
        
        # Wavelength range for precomputation
        wavelength_range = self.config['wavelength_range']
        wl_min = wavelength_range[0]
        wl_max = wavelength_range[1]
        n_precompute = self.config.get('greentab_n_wavelengths', 10)
        
        code = f"""
%% Green Function Tabulation (Required for Substrate)
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('        Setting up Green Function Table for Substrate          \\n');
fprintf('================================================================\\n');
fprintf('⚠ This step is computationally expensive but only done once.\\n');
fprintf('  Grid parameters: nz={nz}, scale={scale}\\n');
fprintf('  Precomputing for %d wavelengths in range [%.1f, %.1f] nm\\n', {n_precompute}, {wl_min}, {wl_max});
fprintf('----------------------------------------------------------------\\n');

% Check if greentab already exists and is compatible
if ~exist( 'greentab', 'var' ) || ~greentab.ismember( layer, enei, p )
    fprintf('Creating new Green function table...\\n');
    
    % Step 1: Create tabulation grid
    fprintf('  Step 1/3: Creating tabulation grid...\\n');
    tab_start = tic;
    tab = tabspace( layer, p, 'nz', {nz}, 'scale', {scale} );
    tab_time = toc(tab_start);
    fprintf('  ✓ Grid created in %.2f seconds\\n', tab_time);
    
    % Step 2: Initialize compgreentablayer
    fprintf('  Step 2/3: Initializing Green function table object...\\n');
    init_start = tic;
    greentab = compgreentablayer( layer, tab );
    init_time = toc(init_start);
    fprintf('  ✓ Initialized in %.2f seconds\\n', init_time);
    
    % Step 3: Precompute for wavelength range
    fprintf('  Step 3/3: Precomputing Green functions...\\n');
    fprintf('  (This may take several minutes)\\n');
    precomp_start = tic;
    
    % Use subset of wavelengths for precomputation
    enei_precomp = linspace( {wl_min}, {wl_max}, {n_precompute} );
    
    % Check if parallel computing is available
    if exist('parallel_enabled', 'var') && parallel_enabled
        fprintf('  Using PARALLEL computation for Green function table\\n');
        greentab = parset( greentab, enei_precomp, op );
    else
        greentab = set( greentab, enei_precomp, op );
    end
    
    precomp_time = toc(precomp_start);
    fprintf('  ✓ Precomputation completed in %.2f seconds (%.2f minutes)\\n', ...
            precomp_time, precomp_time/60);
    
    % Total time
    total_greentab_time = tab_time + init_time + precomp_time;
    fprintf('\\n');
    fprintf('✓ Green function table ready (total: %.2f minutes)\\n', total_greentab_time/60);
else
    fprintf('✓ Using existing compatible Green function table\\n');
end

% Step 4: Add to options structure (CRITICAL!)
op.greentab = greentab;
fprintf('✓ Green function table added to BEM options\\n');
fprintf('================================================================\\n');
fprintf('\\n');
"""
        
        return code
    
    def _generate_bem_solver(self):
        """Generate BEM solver initialization code."""
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        
        code = """
%% Initialize BEM Solver
fprintf('\\nInitializing BEM solver...\\n');
"""
        
        if use_iterative:
            code += """
% Configure iterative solver options
fprintf('  Using iterative BEM solver (for large structures)\\n');
op.iter = bemiter.options( 'output', 1 );
op.iter.tol = 1e-4;
op.iter.maxit = 200;
op.iter.solver = 'gmres';
op.iter.cleaf = 200;
op.iter.htol = 1e-6;
op.iter.kmax = [4, 100];
op.iter.fadmiss = @(rad1,rad2,dist) 2.5 * min(rad1,rad2) < dist;

fprintf('  Iterative solver parameters:\\n');
fprintf('    - Solver: %s\\n', op.iter.solver);
fprintf('    - Tolerance: %g\\n', op.iter.tol);
fprintf('    - Max iterations: %d\\n', op.iter.maxit);
"""
        
        # Add nonlocal refinement if enabled
        if use_nonlocal:
            refine_code = self.nonlocal_gen.generate_refine_function('p')
            
            code += f"""
% Nonlocal refinement for cover layer boundaries
{refine_code}

% Initialize solver with refined integration function
"""
            if use_iterative:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('✓ Nonlocal BEM solver initialized (iterative)\\n');
"""
            else:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('✓ Nonlocal BEM solver initialized (direct)\\n');
"""
        else:
            # Standard BEM solver
            code += """
% Initialize BEM solver
try
    bem = bemsolver(p, op);
    fprintf('BEM solver initialized successfully\\n');
    fprintf('  - Boundary elements: %d\\n', size(p.pos, 1));
catch ME
    fprintf('Error initializing BEM solver: %s\\n', ME.message);
    rethrow(ME);
end
"""
        
        return code
    
    def _generate_excitation(self):
        """Generate excitation configuration."""
        excitation_type = self.config['excitation_type']
        
        if excitation_type == 'planewave':
            code = self._generate_planewave_excitation()
        elif excitation_type == 'dipole':
            code = self._generate_dipole_excitation()
        elif excitation_type == 'eels':
            code = self._generate_eels_excitation()
        else:
            raise ValueError(f"Unknown excitation type: {excitation_type}")
        
        return code
    
    def _generate_planewave_excitation(self):
        """Generate plane wave excitation code."""
        polarizations = self.config['polarizations']
        propagation_dirs = self.config['propagation_dirs']
        
        pol_str = self._python_list_to_matlab(polarizations)
        dir_str = self._python_list_to_matlab(propagation_dirs)
        
        code = f"""
%% Plane Wave Excitation
fprintf('\\nConfiguring plane wave excitation...\\n');

% Polarization vectors
pol = {pol_str};

% Propagation directions
dir = {dir_str};

fprintf('Number of polarizations: %d\\n', size(pol, 1));
fprintf('Number of propagation directions: %d\\n', size(dir, 1));
"""
        return code
    
    def _generate_dipole_excitation(self):
        """Generate dipole excitation code."""
        position = self.config.get('dipole_position', [0, 0, 15])
        moment = self.config.get('dipole_moment', [0, 0, 1])
        
        pos_str = self._python_list_to_matlab([position])
        mom_str = self._python_list_to_matlab([moment])
        
        code = f"""
%% Dipole Excitation
fprintf('\\nConfiguring dipole excitation...\\n');

% Dipole position
dip_pos = {pos_str};

% Dipole moment
dip_mom = {mom_str};

fprintf('Dipole position: [%.2f, %.2f, %.2f] nm\\n', dip_pos(1), dip_pos(2), dip_pos(3));
"""
        return code
    
    def _generate_eels_excitation(self):
        """Generate EELS excitation code."""
        impact = self.config.get('impact_parameter', [10, 0])
        energy = self.config.get('beam_energy', 200e3)
        width = self.config.get('beam_width', 0.2)
        
        code = f"""
%% EELS Excitation
fprintf('\\nConfiguring EELS excitation...\\n');

% Impact parameter
impact = [{impact[0]}, {impact[1]}];

% Beam parameters
beam_energy = {energy};
beam_width = {width};

fprintf('Impact parameter: [%.2f, %.2f] nm\\n', impact(1), impact(2));
fprintf('Beam energy: %.2e eV\\n', beam_energy);
"""
        return code
    
    def _generate_wavelength_loop(self):
        """Generate wavelength loop with parallel support."""
        wavelength_range = self.config['wavelength_range']
        calculate_fields = self.config.get('calculate_fields', False)
        excitation_type = self.config['excitation_type']
        use_parallel = self.config.get('use_parallel', False)
        
        code = f"""
%% Wavelength Loop
wavelength_range = [{wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]}];
enei = linspace(wavelength_range(1), wavelength_range(2), wavelength_range(3));
n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('              Starting BEM Calculation\\n');
fprintf('================================================================\\n');
fprintf('Wavelength range: %.1f - %.1f nm\\n', wavelength_range(1), wavelength_range(2));
fprintf('Number of wavelengths: %d\\n', n_wavelengths);
fprintf('Number of polarizations: %d\\n', n_polarizations);
"""
        
        # Add parallel setup if enabled
        if use_parallel:
            code += self._generate_parallel_setup()
        
        code += """fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""
        
        if calculate_fields:
            code += self._generate_field_setup()
        
        code += """
% Start timer
calculation_start = tic;

"""
        
        # Generate loop - parfor if parallel enabled, regular for otherwise
        if use_parallel:
            code += """% Decide between parfor and for loop based on parallel_enabled flag
if exist('parallel_enabled', 'var') && parallel_enabled
    fprintf('\\nUsing PARALLEL execution (parfor loop)\\n\\n');
    
    % PARALLEL LOOP with parfor
    parfor ien = 1:n_wavelengths
        % Progress indicator (less frequent in parallel mode)
        if mod(ien-1, max(1, floor(n_wavelengths/10))) == 0
            fprintf('  Progress: wavelength %d/%d (λ = %.1f nm)\\n', ien, n_wavelengths, enei(ien));
        end
        
        % Temporary arrays for this wavelength
        sca_temp = zeros(1, n_polarizations);
        ext_temp = zeros(1, n_polarizations);
        abs_temp = zeros(1, n_polarizations);
        
        % Loop over polarizations
        for ipol = 1:n_polarizations
"""
            
            # Excitation code for parallel loop
            if excitation_type == 'planewave':
                code += """            % Plane wave excitation
            exc = planewave(pol(ipol, :), dir(ipol, :), op);
"""
            elif excitation_type == 'dipole':
                code += """            % Dipole excitation
            pt = compoint(p, dip_pos, op);
            dip = dipole(pt, dip_mom, op);
            exc = dip;
"""
            elif excitation_type == 'eels':
                code += """            % EELS excitation
            exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
"""
            
            code += """            
            % Solve BEM equation
            sig = bem \\ exc(p, enei(ien));
            
            % Calculate cross sections
            sca_temp(ipol) = exc.sca(sig);
            ext_temp(ipol) = exc.ext(sig);
            abs_temp(ipol) = ext_temp(ipol) - sca_temp(ipol);
        end
        
        % Store results
        sca(ien, :) = sca_temp;
        ext(ien, :) = ext_temp;
        abs_cross(ien, :) = abs_temp;
    end
    
else
    fprintf('\\nUsing SERIAL execution (regular for loop)\\n\\n');
    
    % SERIAL LOOP (fallback)
    for ien = 1:n_wavelengths
"""
        else:
            code += """% SERIAL LOOP
for ien = 1:n_wavelengths
"""
        
        # Common serial loop body
        code += """        progress_pct = (ien-1) / n_wavelengths * 100;
        
        bar_length = 40;
        filled = floor(bar_length * (ien-1) / n_wavelengths);
        bar = ['[' repmat('=', 1, filled) repmat('.', 1, bar_length - filled) ']'];
        
        fprintf('\\r%s %.1f%% | λ = %.1f nm', bar, progress_pct, enei(ien));
        
        % Loop over polarizations
        for ipol = 1:n_polarizations
"""
        
        # Excitation code for serial loop
        if excitation_type == 'planewave':
            code += """            % Plane wave excitation
            exc = planewave(pol(ipol, :), dir(ipol, :), op);
"""
        elif excitation_type == 'dipole':
            code += """            % Dipole excitation
            pt = compoint(p, dip_pos, op);
            dip = dipole(pt, dip_mom, op);
            exc = dip;
"""
        elif excitation_type == 'eels':
            code += """            % EELS excitation
            exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
"""
        
        code += """            
            % Solve BEM equation
            sig = bem \\ exc(p, enei(ien));
            
            % Calculate cross sections
            sca(ien, ipol) = exc.sca(sig);
            ext(ien, ipol) = exc.ext(sig);
            abs_cross(ien, ipol) = ext(ien, ipol) - sca(ien, ipol);
"""
        
        if calculate_fields:
            code += self._generate_field_calculation_in_loop()
        
        code += """        end
"""
        
        # Close loops
        if use_parallel:
            code += """    end
end
"""
        else:
            code += """end
"""
        
        # Progress completion
        if not use_parallel:
            code += """
% Complete progress bar
fprintf('\\r[');
fprintf(repmat('=', 1, 40));
fprintf('] 100.0%%\\n');
"""
        else:
            code += """
fprintf('\\nAll wavelengths completed\\n');
"""
        
        code += """
calculation_time = toc(calculation_start);
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Calculation completed in %.2f seconds (%.2f minutes)\\n', calculation_time, calculation_time/60);
fprintf('Average time per wavelength: %.2f seconds\\n', calculation_time/n_wavelengths);
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_field_setup(self):
        """Generate field mesh setup code."""
        field_region = self.config.get('field_region', {})
        mindist = self.config.get('field_mindist', 0.2)
        nmax = self.config.get('field_nmax', 2000)
        field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
        
        x_range = field_region.get('x_range', [-50, 50, 101])
        y_range = field_region.get('y_range', [0, 0, 1])
        z_range = field_region.get('z_range', [0, 0, 1])
        
        code = f"""
%% Field Calculation Setup
fprintf('\\nSetting up field calculation mesh...\\n');

"""
        
        if field_wl_idx == 'middle':
            code += "field_wavelength_idx = round(n_wavelengths / 2);\n"
        elif field_wl_idx == 'peak':
            code += "field_wavelength_idx = -1;  % To be determined\n"
        elif isinstance(field_wl_idx, int):
            code += f"field_wavelength_idx = {field_wl_idx};\n"
        else:
            code += "field_wavelength_idx = round(n_wavelengths / 2);\n"
        
        code += "\nfprintf('Field will be calculated at wavelength index: %d\\n', field_wavelength_idx);\n\n"
        
        if y_range[2] == 1:  # xz-plane
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} + 0 * x_grid;
fprintf('Field mesh: xz-plane (y=%.1f), %dx%d points\\n', {y_range[0]}, length(x_field), length(z_field));
"""
        elif z_range[2] == 1:  # xy-plane
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} + 0 * x_grid;
fprintf('Field mesh: xy-plane (z=%.1f), %dx%d points\\n', {z_range[0]}, length(x_field), length(y_field));
"""
        else:  # 3D volume
            code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, y_grid, z_grid] = meshgrid(x_field, y_field, z_field);
fprintf('Field mesh: 3D volume, %dx%dx%d points\\n', length(x_field), length(y_field), length(z_field));
"""
        
        code += f"""
fprintf('Initializing meshfield object...\\n');
emesh = meshfield(p, x_grid, y_grid, z_grid, op, 'mindist', {mindist}, 'nmax', {nmax});
fprintf('  - Minimum distance: {mindist} nm\\n');
fprintf('  - Total field points: %d\\n', numel(x_grid));

field_data = struct();
"""
        
        return code
    
    def _generate_field_calculation_in_loop(self):
        """Generate field calculation code inside wavelength loop."""
        code = """
            % Calculate fields at selected wavelength
            if ien == field_wavelength_idx
                fprintf('\\n  → Calculating fields at λ = %.1f nm...\\n', enei(ien));
                field_calc_start = tic;
                
                e_induced = emesh(sig);
                e_incoming = emesh(exc.field(emesh.pt, enei(ien)));
                e_total = e_induced + e_incoming;
                
                e_intensity = dot(e_total, e_total, 3);
                e0_intensity = dot(e_incoming, e_incoming, 3);
                enhancement = sqrt(e_intensity ./ e0_intensity);
                
                field_data(ipol).polarization = pol(ipol, :);
                field_data(ipol).wavelength = enei(ien);
                field_data(ipol).e_total = e_total;
                field_data(ipol).enhancement = enhancement;
                field_data(ipol).intensity = e_intensity;
                field_data(ipol).x_grid = x_grid;
                field_data(ipol).y_grid = y_grid;
                field_data(ipol).z_grid = z_grid;
                
                field_calc_time = toc(field_calc_start);
                fprintf('  → Field calculation completed in %.2f seconds\\n', field_calc_time);
            end
"""
        return code
    
    def _generate_save_results(self):
        """Generate code to save simulation results."""
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = """
%% Save Results
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Saving results...\\n');

results = struct();
results.wavelength = enei;
results.scattering = sca;
results.extinction = ext;
results.absorption = abs_cross;
results.polarizations = pol;
results.propagation_dirs = dir;
results.calculation_time = calculation_time;
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    results.fields = field_data;
    fprintf('Field data included in results\\n');
end
"""
        
        code += """
save('simulation_results.mat', 'results');
fprintf('✓ Results saved to: simulation_results.mat\\n');

% Save cross sections to text file
fid = fopen('simulation_results.txt', 'w');
fprintf(fid, 'Wavelength(nm)\\t');
for ipol = 1:n_polarizations
    fprintf(fid, 'Sca_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    fprintf(fid, 'Ext_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    if ipol < n_polarizations
        fprintf(fid, 'Abs_pol%d\\t', ipol);
    else
        fprintf(fid, 'Abs_pol%d', ipol);
    end
end
fprintf(fid, '\\n');

for i = 1:length(enei)
    fprintf(fid, '%.2f\\t', enei(i));
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', sca(i, ipol));
    end
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', ext(i, ipol));
    end
    for ipol = 1:n_polarizations
        if ipol < n_polarizations
            fprintf(fid, '%.6e\\t', abs_cross(i, ipol));
        else
            fprintf(fid, '%.6e', abs_cross(i, ipol));
        end
    end
    fprintf(fid, '\\n');
end
fclose(fid);
fprintf('✓ Cross sections saved to: simulation_results.txt\\n');
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    save('field_data.mat', 'field_data', '-v7.3');
    fprintf('✓ Field data saved to: field_data.mat\\n');
end
"""
        
        code += """
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_footer(self):
        """Generate script footer with proper cleanup and exit."""
        use_parallel = self.config.get('use_parallel', False)
        
        code = """
%% Cleanup and Exit
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Cleaning up...\\n');

"""
        
        # Add parallel cleanup if parallel was enabled
        if use_parallel:
            code += self._generate_parallel_cleanup()
        
        code += """
% Close all waitbars
try
    multiWaitbar('CloseAll');
    fprintf('  ✓ Closed all waitbars\\n');
catch
    % multiWaitbar not used or already closed
end

% Close all figures
close all;
fprintf('  ✓ Closed all figures\\n');

% Clear large variables to free memory
clear bem sig field_data meshfield;
fprintf('  ✓ Cleared temporary variables\\n');

fprintf('================================================================\\n');
fprintf('\\n');
fprintf('=== MNPBEM Simulation Completed Successfully ===\\n');
fprintf('\\n');

%% Exit MATLAB
quit force;
"""
        return code
    
    def _python_list_to_matlab(self, python_list):
        """Convert Python list to MATLAB array string."""
        if not python_list:
            return '[]'
        
        if isinstance(python_list[0], (list, tuple)):
            rows = []
            for row in python_list:
                row_str = ', '.join([str(x) for x in row])
                rows.append(row_str)
            return '[' + '; '.join(rows) + ']'
        else:
            return '[' + ', '.join([str(x) for x in python_list]) + ']'

    def _extract_closed_args(self, material_code):
        """Extract closed arguments from material code."""
        # Find: closed = [1, 2];
        if 'closed = [' in material_code:
            start = material_code.find('closed = [') + len('closed = [')
            end = material_code.find(']', start)
            self._closed_args = material_code[start:end].strip()
        else:
            # Single value: closed = 1;
            if 'closed = ' in material_code:
                start = material_code.find('closed = ') + len('closed = ')
                end = material_code.find(';', start)
                self._closed_args = material_code[start:end].strip()
            else:
                self._closed_args = "1"