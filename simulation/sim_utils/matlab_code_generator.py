"""
MATLAB Code Generator

Generates complete MATLAB simulation scripts with field calculation support.
Supports nonlocal quantum corrections for sub-nanometer gaps.
Supports parallel computing with parfor (single node, multiple cores).
"""
import os
import numpy as np
from .nonlocal_generator import NonlocalGenerator


class MatlabCodeGenerator:
    """Generates complete MATLAB simulation code."""
    
    def __init__(self, config, verbose=False):
        self.config = config
        self.verbose = verbose

        # Auto-disable H2 compression when substrate is used (known MNPBEM MEX bug)
        use_substrate = config.get('use_substrate', False)
        use_h2 = config.get('use_h2_compression', False)

        if use_substrate and use_h2:
            print("[!] WARNING: H2 compression is incompatible with substrate mode")
            print("    (MNPBEM MEX file 'hmatgreentab1' causes segmentation fault)")
            print("    -> Automatically disabling H2 compression")
            self.config['use_h2_compression'] = False

        self.nonlocal_gen = NonlocalGenerator(config, verbose)
    
    def generate_complete_script(self, geometry_code, material_code):
        """Generate complete MATLAB simulation script."""

        self._extract_closed_args(material_code)
        
        # Header
        header = self._generate_header()
        
        # Options
        options = self._generate_options()
        
        # Geometry
        geometry = geometry_code
        
        # Materials
        materials = material_code
        
        # Comparticle creation
        comparticle = self._generate_comparticle()
        
        # Validation (if nonlocal)
        validation = self._validate_nonlocal_setup()

        # Green function tabulation
        greentab = self._generate_substrate_greentab()
        
        # BEM solver
        bem_solver = self._generate_bem_solver()
        
        # Excitation
        excitation = self._generate_excitation()

        # Wavelength loop (with chunking support!)
        chunk_size = self.config.get('wavelength_chunk_size', None)
        if chunk_size:
            # Use memory-efficient chunking
            wavelength_loop = self._generate_wavelength_loop_with_chunking()
            if self.verbose:
                print(f"✓ Using wavelength chunking: {chunk_size} wavelengths per chunk")
        else:
            # Use standard loop
            wavelength_loop = self._generate_wavelength_loop()
            if self.verbose:
                print("✓ Using standard wavelength loop (no chunking)")
        
        # Save results
        save_results = self._generate_save_results()
        
        # Footer (now with parallel cleanup!)
        footer = self._generate_footer()
        
        # Combine all parts
        complete_code = f"""{header}

{options}

{geometry}

{materials}

{comparticle}

{validation}

{greentab}

{bem_solver}

{excitation}

{wavelength_loop}

{save_results}

{footer}
"""
        return complete_code
    
    def _generate_header(self):
        """Generate script header."""
        code = """% MNPBEM Simulation Script
% Auto-generated by MNPBEM Automation Pipeline
%
% DO NOT EDIT THIS FILE MANUALLY
% Modify the configuration file instead and regenerate

clear all;
close all;
clc;

fprintf('=== MNPBEM Simulation Started ===\\n');
fprintf('Structure: %s\\n', '{structure}');
fprintf('Simulation Type: %s\\n', '{sim_type}');
""".format(
            structure=self.config['structure'],
            sim_type=self.config['simulation_type']
        )
        return code
    
    def _generate_options(self):
        """Generate BEM options with proper settings."""
        sim_type = self.config['simulation_type']
        use_mirror = self.config.get('use_mirror_symmetry', False)
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        use_substrate = self.config.get('use_substrate', False)

        if use_substrate and sim_type != 'ret':
            raise ValueError(
                "Substrate simulations require 'ret' (retarded) simulation type. "
                f"Current simulation_type is '{sim_type}'. "
                "Please set: args['simulation_type'] = 'ret'"
            )
        
        refine = self.config.get('refine', 3 if use_nonlocal else 1)
        relcutoff = self.config.get('relcutoff', 2 if use_iterative else 3)
        
        code = f"""
%% BEM Options
fprintf('\\nSetting up BEM options...\\n');
"""
        
        # Base options
        if sim_type == 'stat':
            code += "op = bemoptions( 'sim', 'stat', 'interp', 'curv' );\n"
        else:
            code += "op = bemoptions( 'sim', 'ret', 'interp', 'curv' );\n"
        
        code += f"op.refine = {refine};\n"

        if use_substrate:
            code += """
fprintf('  [OK] Substrate mode enabled\\n');
fprintf('  [!] Green function tabulation will be required\\n');
"""
        
        # Mirror symmetry
        if use_mirror:
            if isinstance(use_mirror, str):
                sym = use_mirror
            else:
                sym = 'xy'
            code += f"op.sym = '{sym}';\n"
            code += "use_mirror = true;  % Flag for field calculation\n"
            code += f"fprintf('  [OK] Mirror symmetry: {sym}\\n');\n"
        else:
            code += "use_mirror = false;  % No mirror symmetry\n"
        
        # Nonlocal options (high precision integration)
        if use_nonlocal:
            nonlocal_opts = self.nonlocal_gen.generate_bem_options()
            code += nonlocal_opts
        
        # Iterative solver options
        if use_iterative:
            code += f"""
%% Iterative Solver Options
relcutoff = {relcutoff};
fprintf('  [OK] Iterative solver: relcutoff=%d\\n', relcutoff);
"""
        
        code += "\nfprintf('[OK] BEM options configured\\n');\n"
        
        return code
    
    def _generate_parallel_setup(self):
        """Generate parallel pool setup code with computational threads control."""
        num_workers = self.config.get('num_workers', 'auto')
        max_comp_threads = self.config.get('max_comp_threads', 'auto')
        
        code = """
%% Parallel Computing Setup
fprintf('\\n=== Setting up Parallel Computing ===\\n');

"""
        
        # Determine number of workers based on config
        if num_workers == 'env':
            code += """% Get number of workers from environment variable
if ~isempty(getenv('MNPBEM_NUM_WORKERS'))
    requested_workers = str2double(getenv('MNPBEM_NUM_WORKERS'));
    fprintf('Reading from environment: MNPBEM_NUM_WORKERS=%d\\n', requested_workers);
elseif ~isempty(getenv('SLURM_CPUS_PER_TASK'))
    requested_workers = str2double(getenv('SLURM_CPUS_PER_TASK'));
    fprintf('Detected Slurm environment: SLURM_CPUS_PER_TASK=%d\\n', requested_workers);
else
    requested_workers = feature('numcores');
    fprintf('Auto-detected available cores: %d\\n', requested_workers);
end
"""
        elif num_workers == 'auto':
            code += """% Auto-detect available cores
requested_workers = feature('numcores');
fprintf('Auto-detected available cores: %d\\n', requested_workers);
"""
        elif isinstance(num_workers, int):
            code += f"""% Using specified number of workers
requested_workers = {num_workers};
fprintf('Using specified workers: %d\\n', requested_workers);
"""
        else:
            code += """% Default to 1 worker (serial)
requested_workers = 1;
fprintf('Using default: 1 worker (serial execution)\\n');
"""
        
        # NEW: Computational threads configuration
        code += """
%% Computational Threads Configuration
% Control threads used by BLAS, FFT, and other low-level operations
total_cores = feature('numcores');
fprintf('\\nTotal system cores: %d\\n', total_cores);

"""
        
        if max_comp_threads == 'auto':
            code += """% Auto-calculate: divide cores by workers
if requested_workers > 1
    % Parallel mode: divide cores among workers
    comp_threads = max(1, floor(total_cores / requested_workers));
    fprintf('Auto-calculated computational threads: %d per worker\\n', comp_threads);
    fprintf('  (Total cores %d / %d workers = %d threads each)\\n', ...
            total_cores, requested_workers, comp_threads);
else
    % Serial mode: use all cores for single worker
    comp_threads = total_cores;
    fprintf('Serial mode: using all %d cores for computational threads\\n', comp_threads);
end
"""
        elif max_comp_threads == 'max':
            code += """% Use maximum: all cores for each worker (may cause over-subscription!)
comp_threads = total_cores;
fprintf('WARNING: Using all %d cores per worker\\n', comp_threads);
if requested_workers > 1
    fprintf('  This will cause over-subscription: %d workers × %d threads = %d threads!\\n', ...
            requested_workers, comp_threads, requested_workers * comp_threads);
end
"""
        elif isinstance(max_comp_threads, int):
            code += f"""% Using specified computational threads
comp_threads = {max_comp_threads};
fprintf('Using specified computational threads: %d per worker\\n', comp_threads);
"""
        else:
            code += """% Default: 1 thread per worker
comp_threads = 1;
fprintf('Using default: 1 computational thread per worker\\n');
"""
        
        code += """
% Set computational threads
fprintf('Setting maxNumCompThreads to %d...\\n', comp_threads);
maxNumCompThreads(comp_threads);
current_threads = maxNumCompThreads();
fprintf('  [OK] Current maxNumCompThreads: %d\\n', current_threads);

% Display parallelism summary
fprintf('\\n--- Parallelism Configuration ---\\n');
fprintf('  Workers (parfor):        %d\\n', requested_workers);
fprintf('  Threads per worker:      %d\\n', comp_threads);
fprintf('  Total parallel threads:  %d\\n', requested_workers * comp_threads);
fprintf('  System cores available:  %d\\n', total_cores);
if requested_workers * comp_threads > total_cores
    fprintf('  [!] WARNING: Over-subscription detected!\\n');
    fprintf('     %d parallel threads competing for %d cores\\n', ...
            requested_workers * comp_threads, total_cores);
else
    fprintf('  [OK] Good: No over-subscription\\n');
end
fprintf('----------------------------------\\n\\n');

"""
        
        code += """
% Create parallel pool
try
    % Check if pool already exists
    existing_pool = gcp('nocreate');
    
    if isempty(existing_pool)
        % No existing pool, create new one
        if requested_workers > 1
            fprintf('Creating parallel pool with %d workers...\\n', requested_workers);
            pool = parpool('local', requested_workers);
            fprintf('[OK] Parallel pool created successfully: %d workers\\n', pool.NumWorkers);

            % CRITICAL: Propagate maxNumCompThreads to ALL workers!
            % Without this, workers use default threads (usually 1)
            fprintf('Setting maxNumCompThreads(%d) on all workers...\\n', comp_threads);
            pctRunOnAll(sprintf('maxNumCompThreads(%d);', comp_threads));

            % Verify the setting was applied
            fprintf('Verifying worker thread settings...\\n');
            worker_threads = zeros(1, pool.NumWorkers);
            parfor i = 1:pool.NumWorkers
                worker_threads(i) = maxNumCompThreads();
            end
            fprintf('  Worker thread counts: [%s]\\n', num2str(worker_threads));
            if all(worker_threads == comp_threads)
                fprintf('[OK] All %d workers confirmed with %d threads each\\n', pool.NumWorkers, comp_threads);
            else
                fprintf('[WARNING] Thread mismatch! Expected %d, got: [%s]\\n', comp_threads, num2str(worker_threads));
            end

            parallel_enabled = true;
        else
            fprintf('Serial execution mode (1 worker)\\n');
            pool = [];
            parallel_enabled = false;
        end
    else
        % Pool exists, use it
        pool = existing_pool;
        fprintf('[OK] Using existing parallel pool: %d workers\\n', pool.NumWorkers);

        % Also set threads on existing pool workers
        fprintf('Setting maxNumCompThreads(%d) on existing workers...\\n', comp_threads);
        pctRunOnAll(sprintf('maxNumCompThreads(%d);', comp_threads));

        % Verify the setting was applied
        fprintf('Verifying worker thread settings...\\n');
        worker_threads = zeros(1, pool.NumWorkers);
        parfor i = 1:pool.NumWorkers
            worker_threads(i) = maxNumCompThreads();
        end
        fprintf('  Worker thread counts: [%s]\\n', num2str(worker_threads));
        if all(worker_threads == comp_threads)
            fprintf('[OK] All %d workers confirmed with %d threads each\\n', pool.NumWorkers, comp_threads);
        else
            fprintf('[WARNING] Thread mismatch! Expected %d, got: [%s]\\n', comp_threads, num2str(worker_threads));
        end

        parallel_enabled = true;
    end
    
catch ME
    fprintf('[!] Warning: Failed to create parallel pool\\n');
    fprintf('Error: %s\\n', ME.message);
    fprintf('Continuing with serial execution...\\n');
    pool = [];
    parallel_enabled = false;
end

fprintf('=== Parallel Setup Complete ===\\n\\n');
"""
        return code
    
    def _generate_parallel_cleanup(self):
        """
        Generate safe parallel pool cleanup code.
        
        IMPROVEMENTS:
        1. Longer timeout for worker termination (15 seconds)
        2. Force kill if timeout
        3. Better verification
        """
        code = """
%% Parallel Computing Cleanup (IMPROVED!)
if exist('parallel_enabled', 'var') && parallel_enabled && ~isempty(gcp('nocreate'))
    fprintf('\\nCleaning up parallel pool...\\n');
    
    try
        pool = gcp('nocreate');
        if ~isempty(pool)
            % Get pool info
            n_workers = pool.NumWorkers;
            fprintf('  Shutting down %d workers...\\n', n_workers);
            
            % Delete the pool
            delete(pool);
            
            % IMPROVED: Wait with timeout for complete termination
            fprintf('  Waiting for workers to terminate...\\n');
            timeout = 15;  % 15 seconds timeout (increased from 2!)
            start_time = tic;
            
            while ~isempty(gcp('nocreate')) && toc(start_time) < timeout
                pause(0.5);
                % Print status every 3 seconds
                if mod(toc(start_time), 3) < 0.5
                    fprintf('    Still waiting... (%.1f seconds elapsed)\\n', toc(start_time));
                end
            end
            
            % Verify pool is completely gone
            remaining_pool = gcp('nocreate');
            if isempty(remaining_pool)
                fprintf('  [OK] Parallel pool closed successfully\\n');
            else
                fprintf('  WARNING: Pool cleanup timeout after %.1f seconds\\n', timeout);
                fprintf('     Some workers may still be running\\n');
                fprintf('     MATLAB will force-terminate on exit\\n');
                % Try force delete one more time
                try
                    delete(gcp('nocreate'));
                catch
                    % Ignore errors - will be cleaned up on exit
                end
            end
        end
    catch ME
        fprintf('  Warning during pool cleanup: %s\\n', ME.message);
        fprintf('     Continuing with exit anyway...\\n');
    end
end
"""
        return code
    
    def _generate_comparticle(self):
        """Generate comparticle object creation with visualization."""

        # Get closed indices from material manager
        closed_args = self._closed_args

        # Check if substrate is used
        use_substrate = self.config.get('use_substrate', False)

        # Check if mirror symmetry is used
        use_mirror = self.config.get('use_mirror_symmetry', False)

        if use_substrate:
            substrate = self.config.get('substrate', {})
            substrate_position = substrate.get('position', 0)

        # Select comparticle or comparticlemirror based on mirror symmetry
        if use_mirror:
            comparticle_func = "comparticlemirror"
            comparticle_msg = f"Comparticlemirror created with mirror symmetry ''{use_mirror}''"
        else:
            comparticle_func = "comparticle"
            comparticle_msg = "Comparticle created"

        code = f"""
%% Create Comparticle Object
fprintf('\\nCreating comparticle object...\\n');
p = {comparticle_func}(epstab, particles, inout, """ + closed_args + f""", op);
fprintf('{comparticle_msg} with %d boundary elements\\n', p.n);

%% Visualize and Save Structure
fprintf('\\nGenerating structure visualizations...\\n');

try
    n_particles = length(particles);
    
    % Define colors
    core_color = [1.0, 0.7, 0.3];  % Gold/orange for core
    shell_color_1 = [0.7, 0.85, 1.0];  % Light blue
    shell_color_2 = [0.5, 0.7, 0.95];  % Medium blue
    shell_color_3 = [0.3, 0.5, 0.9];   % Darker blue
    substrate_color = [0.85, 0.85, 0.85];  % Light gray
    
"""
        
        # Add substrate parameters
        if use_substrate:
            code += f"""    % Substrate parameters
    has_substrate = true;
    z_substrate = {substrate_position};
"""
        else:
            code += """    % No substrate
    has_substrate = false;
"""
        
        code += """    
    % Get particle bounds for plotting
    x_lim = [min(p.pos(:,1)), max(p.pos(:,1))];
    y_lim = [min(p.pos(:,2)), max(p.pos(:,2))];
    z_lim = [min(p.pos(:,3)), max(p.pos(:,3))];
    
    % Expand limits for substrate visualization
    x_expand = (x_lim(2) - x_lim(1)) * 0.3;
    y_expand = (y_lim(2) - y_lim(1)) * 0.3;
    x_range = [x_lim(1) - x_expand, x_lim(2) + x_expand];
    y_range = [y_lim(1) - y_expand, y_lim(2) + y_expand];
    
    % ========== 3D View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    % Check if single or multi-particle structure
    if n_particles == 1
        % Single particle: simple plot
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        % Multi-particle (core-shell): plot with progressive transparency
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                % Core: opaque, gold color
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                % Shells: progressively more transparent
                shell_idx = i - 1;
                
                % Select transparency and color
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    % General case
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
        
        % Add legend for multi-layer structures
        legend_entries = cell(n_particles, 1);
        legend_entries{1} = 'Core';
        for i = 2:n_particles
            legend_entries{i} = sprintf('Shell %d', i-1);
        end
        legend(legend_entries, 'Location', 'northeast', 'FontSize', 10);
    end
    
    % Draw substrate interface (3D view)
    if has_substrate
        % Create substrate plane
        [X_sub, Y_sub] = meshgrid(x_range, y_range);
        Z_sub = ones(size(X_sub)) * z_substrate;
        surf(X_sub, Y_sub, Z_sub, 'FaceColor', substrate_color, ...
             'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Draw interface outline
        plot3([x_range(1), x_range(2), x_range(2), x_range(1), x_range(1)], ...
              [y_range(1), y_range(1), y_range(2), y_range(2), y_range(1)], ...
              [z_substrate, z_substrate, z_substrate, z_substrate, z_substrate], ...
              'k-', 'LineWidth', 2);
        
        % Add label
        text(x_range(2)*0.8, y_range(2)*0.8, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('3D View', 'FontSize', 14, 'FontWeight', 'bold');
    view(45, 30);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver3(0, 0, 0, arrow_len, 0, 0, 'Color', 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, arrow_len, 0, 'Color', 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, 0, arrow_len, 'Color', 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 0, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0, 0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    axis equal;
    axis off;
    view(45, 30);
    xlim([-0.3, 1.5]);
    ylim([-0.3, 1.5]);
    zlim([-0.3, 1.5]);
    
    print('structure_3D.png', '-dpng', '-r300');
    fprintf('  [OK] 3D view saved\\n');
    close(fig);
    
    % ========== XY View (Top View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Substrate outline in XY view
    if has_substrate
        rectangle('Position', [x_range(1), y_range(1), ...
                              x_range(2)-x_range(1), y_range(2)-y_range(1)], ...
                 'EdgeColor', 'k', 'LineWidth', 2, 'LineStyle', '--');
        text(x_range(2)*0.85, y_range(2)*0.85, ...
             sprintf('Substrate z=%.1f', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k');
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('XY View (Top View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 90);
    grid on;
    box on;
    
    print('structure_XY.png', '-dpng', '-r300');
    fprintf('  [OK] XY view saved\\n');
    close(fig);
    
    % ========== YZ View (Side View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (YZ view - FIXED!)
    if has_substrate
        % Substrate line: x=0 plane, along y-axis, at z=z_substrate
        plot3([0, 0], ...
              [y_range(1), y_range(2)], ...
              [z_substrate, z_substrate], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        y_fill = [y_range(1), y_range(2), y_range(2), y_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(y_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator: vertical line at y=y_mid
            y_mid = mean(y_range);
            plot3([0, 0], [y_mid, y_mid], [particle_bottom, z_substrate], ...
                  'r-', 'LineWidth', 2);
            text(0, y_mid, (particle_bottom + z_substrate)/2, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(0, y_range(2)*0.85, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('YZ View (Side View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(90, 0);
    grid on;
    box on;
    
    print('structure_YZ.png', '-dpng', '-r300');
    fprintf('  [OK] YZ view saved\\n');
    close(fig);
    
    % ========== ZX View (Front View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (ZX view - FIXED!)
    if has_substrate
        % Substrate line: y=0 plane, along x-axis, at z=z_substrate
        plot3([x_range(1), x_range(2)], ...
              [0, 0], ...
              [z_substrate, z_substrate], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        x_fill = [x_range(1), x_range(2), x_range(2), x_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(x_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator: vertical line at x=x_mid
            x_mid = mean(x_range);
            plot3([x_mid, x_mid], [0, 0], [particle_bottom, z_substrate], ...
                  'r-', 'LineWidth', 2);
            text(x_mid, 0, (particle_bottom + z_substrate)/2, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(x_range(2)*0.85, 0, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('ZX View (Front View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 0);
    grid on;
    box on;
    
    print('structure_ZX.png', '-dpng', '-r300');
    fprintf('  [OK] ZX view saved\\n');
    close(fig);

    fprintf('  [OK] All structure visualizations completed!\\n');
    
catch ME
    fprintf('  Warning: Could not save structure plots: %s\\n', ME.message);
end
"""

        return code
    
    def _validate_nonlocal_setup(self):
        """Validate that nonlocal setup is correct."""
        if not self.nonlocal_gen.is_needed():
            return ""
        
        code = """
%% Validate Nonlocal Setup
fprintf('\\n=== Validating Nonlocal Setup ===\\n');

% Check number of particles
n_particles = length(particles);
fprintf('  Number of particle boundaries: %d\\n', n_particles);

% Check epstab
n_materials = length(epstab);
fprintf('  Number of materials in epstab: %d\\n', n_materials);

% Check inout matrix
[n_boundaries, ~] = size(inout);
fprintf('  Number of boundaries in inout: %d\\n', n_boundaries);

% Validation
if n_particles ~= n_boundaries
    error('Mismatch: %d particles but %d boundaries in inout!', n_particles, n_boundaries);
end

fprintf('[OK] Nonlocal setup validated\\n');
"""
        return code

    def _generate_substrate_greentab(self):
        """Generate Green function tabulation with field point coverage."""
        use_substrate = self.config.get('use_substrate', False)
        sim_type = self.config['simulation_type']
        
        if not (use_substrate and sim_type == 'ret'):
            return ""
        
        nz = self.config.get('greentab_nz', 30)
        scale = self.config.get('greentab_scale', 1.5)
        
        wavelength_range = self.config['wavelength_range']
        wl_min = wavelength_range[0]
        wl_max = wavelength_range[1]
        wl_num = wavelength_range[2]
        
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = f"""
%% Green Function Tabulation (Required for Substrate)
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('        Setting up Green Function Table for Substrate          \\n');
fprintf('================================================================\\n');

% CRITICAL: Define actual simulation wavelengths FIRST
enei = linspace({wl_min}, {wl_max}, {wl_num});
fprintf('Simulation wavelengths: %.1f to %.1f nm (%d points)\\n', ...
        min(enei), max(enei), length(enei));
"""

        # FIX: Field points를 tabulation에 포함!
        if calculate_fields:
            field_region = self.config.get('field_region', {})
            x_range = field_region.get('x_range', [-50, 50, 101])
            y_range = field_region.get('y_range', [0, 0, 1])
            z_range = field_region.get('z_range', [0, 0, 1])
            
            code += """
% Set up field points for Green function tabulation
fprintf('\\nPreparing field mesh for tabulation...\\n');
"""
        
            if y_range[2] == 1:  # xz-plane
                code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
            elif z_range[2] == 1:  # xy-plane
                code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
        
            code += """
% Store grid shape for later use
grid_shape = size(x_grid);
fprintf('Field grid: %dx%d points\\n', grid_shape(1), grid_shape(2));

% Create compoint object for field mesh (CRITICAL for tabulation!)
fprintf('  Creating compoint for field mesh...\\n');
pt_field = compoint(p, [x_grid(:), y_grid(:), z_grid(:)], op);
fprintf('  -> Field points: %d\\n', pt_field.n);

% Check compatibility: particle + field points
if ~exist('greentab', 'var') || ~greentab.ismember(layer, enei, {p, pt_field})
    fprintf('Creating new Green function table...\\n');
    
    % CRITICAL FIX: Include BOTH particle and field points in tabulation!
    fprintf('  Creating tabulation grid (particle + field points)...\\n');
"""
        
            code += f"""    tab = tabspace(layer, {{p, pt_field}}, 'nz', {nz}, 'scale', {scale});
    
    % Initialize Green function table
    fprintf('  Initializing compgreentablayer...\\n');
    greentab = compgreentablayer(layer, tab);
    
    % Precompute for actual simulation wavelengths
    fprintf('  Precomputing Green functions for %d wavelengths...\\n', length(enei));
    fprintf('  This may take several minutes...\\n');
    
    tic_start = tic;
    greentab = set(greentab, enei, op);
    time_elapsed = toc(tic_start);
    
    fprintf('  [OK] Green function table ready (%.1f seconds)\\n', time_elapsed);
else
    fprintf('[OK] Using existing compatible Green function table\\n');
end
"""
        else:
            # No field calculation: particle only (original behavior)
            code += """
% No field calculation: tabulate for particle only
if ~exist('greentab', 'var') || ~greentab.ismember(layer, enei, p)
    fprintf('Creating new Green function table...\\n');

    % Create tabulation grid for particle ONLY
    fprintf('  Creating tabulation grid (particle only)...\\n');
"""

            code += f"""    tab = tabspace(layer, p, 'nz', {nz}, 'scale', {scale});

    % Initialize Green function table
    fprintf('  Initializing compgreentablayer...\\n');
    greentab = compgreentablayer(layer, tab);

    % Precompute for actual simulation wavelengths
    fprintf('  Precomputing Green functions for %d wavelengths...\\n', length(enei));
    fprintf('  This may take several minutes...\\n');

    tic_start = tic;
    greentab = set(greentab, enei, op);
    time_elapsed = toc(tic_start);

    fprintf('  [OK] Green function table ready (%.1f seconds)\\n', time_elapsed);
else
    fprintf('[OK] Using existing compatible Green function table\\n');
end
"""

        code += """
% Add to options
op.greentab = greentab;
fprintf('[OK] Green function table added to BEM options\\n\\n');
"""

        return code
    
    def _generate_bem_solver(self):
        """Generate BEM solver initialization code."""
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        
        code = """
%% Initialize BEM Solver
fprintf('\\nInitializing BEM solver...\\n');
"""
        
        if use_iterative:
            code += """
% Configure iterative solver options
fprintf('  Using iterative BEM solver (for large structures)\\n');
op.iter = bemiter.options( 'output', 1 );
op.iter.tol = 1e-4;
op.iter.maxit = 200;
op.iter.solver = 'gmres';
op.iter.cleaf = 200;
op.iter.htol = 1e-6;
op.iter.kmax = [4, 100];
op.iter.fadmiss = @(rad1,rad2,dist) 2.5 * min(rad1,rad2) < dist;

fprintf('  Iterative solver parameters:\\n');
fprintf('    - Solver: %s\\n', op.iter.solver);
fprintf('    - Tolerance: %g\\n', op.iter.tol);
fprintf('    - Max iterations: %d\\n', op.iter.maxit);
"""
        
        # Add nonlocal refinement if enabled
        if use_nonlocal:
            refine_code = self.nonlocal_gen.generate_refine_function('p')
            
            code += f"""
% Nonlocal refinement for cover layer boundaries
{refine_code}

% Initialize solver with refined integration function
"""
            if use_iterative:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('[OK] Nonlocal BEM solver initialized (iterative)\\n');
"""
            else:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('[OK] Nonlocal BEM solver initialized (direct)\\n');
"""
        else:
            # Standard BEM solver
            code += """
% Initialize BEM solver
try
    bem = bemsolver(p, op);
    fprintf('BEM solver initialized successfully\\n');
    fprintf('  - Boundary elements: %d\\n', size(p.pos, 1));
catch ME
    fprintf('Error initializing BEM solver: %s\\n', ME.message);
    rethrow(ME);
end
"""
        
        return code
    
    def _generate_excitation(self):
        """Generate excitation configuration."""
        excitation_type = self.config['excitation_type']
        use_mirror = self.config.get('use_mirror_symmetry', False)

        # Check EELS + mirror incompatibility
        if excitation_type == 'eels' and use_mirror:
            raise ValueError(
                "EELS excitation is NOT compatible with mirror symmetry. "
                "Please set use_mirror_symmetry = False for EELS simulations."
            )

        if excitation_type == 'planewave':
            code = self._generate_planewave_excitation()
        elif excitation_type == 'dipole':
            code = self._generate_dipole_excitation()
        elif excitation_type == 'eels':
            code = self._generate_eels_excitation()
        else:
            raise ValueError(f"Unknown excitation type: {excitation_type}")

        return code
    
    def _generate_planewave_excitation(self):
        """Generate plane wave excitation code."""
        polarizations = self.config['polarizations']
        propagation_dirs = self.config['propagation_dirs']
        
        pol_str = self._python_list_to_matlab(polarizations)
        dir_str = self._python_list_to_matlab(propagation_dirs)
        
        code = f"""
%% Plane Wave Excitation
fprintf('\\nConfiguring plane wave excitation...\\n');

% Polarization vectors
pol = {pol_str};

% Propagation directions
dir = {dir_str};

fprintf('Number of polarizations: %d\\n', size(pol, 1));
fprintf('Number of propagation directions: %d\\n', size(dir, 1));
"""
        return code
    
    def _generate_dipole_excitation(self):
        """Generate dipole excitation code."""
        position = self.config.get('dipole_position', [0, 0, 15])
        moment = self.config.get('dipole_moment', [0, 0, 1])
        
        pos_str = self._python_list_to_matlab([position])
        mom_str = self._python_list_to_matlab([moment])
        
        code = f"""
%% Dipole Excitation
fprintf('\\nConfiguring dipole excitation...\\n');

% Dipole position
dip_pos = {pos_str};

% Dipole moment
dip_mom = {mom_str};

% Dummy polarization for code compatibility
pol = [0, 0, 1];  % Single "polarization" for dipole
dir = [0, 0, 1];  % Dummy propagation direction

fprintf('Dipole position: [%.2f, %.2f, %.2f] nm\\n', dip_pos(1), dip_pos(2), dip_pos(3));
"""
        return code
    
    def _generate_eels_excitation(self):
        """Generate EELS excitation code."""
        impact = self.config.get('impact_parameter', [10, 0])
        energy = self.config.get('beam_energy', 200e3)
        width = self.config.get('beam_width', 0.2)
        
        code = f"""
%% EELS Excitation
fprintf('\\nConfiguring EELS excitation...\\n');

% Impact parameter
impact = [{impact[0]}, {impact[1]}];

% Beam parameters
beam_energy = {energy};
beam_width = {width};

% Dummy polarization for code compatibility
pol = [0, 0, 1];  % Single "polarization" for EELS
dir = [0, 0, 1];  % Dummy propagation direction

fprintf('Impact parameter: [%.2f, %.2f] nm\\n', impact(1), impact(2));
fprintf('Beam energy: %.2e eV\\n', beam_energy);
"""
        return code

    def _generate_wavelength_loop(self):
        """
        Generate wavelength loop with proper parallel execution.
        
        CRITICAL FIXES (2024-12-03):
        1. Excitation MUST be initialized OUTSIDE parfor loop
        2. MNPBEM processes ALL polarizations at once (no polarization loop needed)
        3. Improved error handling and pool cleanup
        
        Based on MNPBEM official example: Demo/planewave/ret/demospecret9.m
        """
        wavelength_range = self.config['wavelength_range']
        calculate_fields = self.config.get('calculate_fields', False)
        excitation_type = self.config['excitation_type']
        use_parallel = self.config.get('use_parallel', False)
        
        code = f"""
%% Wavelength Loop
% Note: 'enei' was already defined in Green function section if substrate is used
if ~exist('enei', 'var')
    enei = linspace({wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]});
end

n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('              Starting BEM Calculation\\n');
fprintf('================================================================\\n');
fprintf('Wavelength range: %.1f - %.1f nm (%d points)\\n', ...
        min(enei), max(enei), n_wavelengths);
fprintf('Number of polarizations: %d\\n', n_polarizations);
"""
        
        # Add parallel setup if enabled
        if use_parallel:
            code += self._generate_parallel_setup()
        
        code += """fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""
        
        if calculate_fields:
            code += self._generate_field_setup()
        
        # CRITICAL FIX 1: Initialize excitation BEFORE the loop!
        code += """
%% Initialize Excitation Object (CRITICAL: Must be before parallel loop!)
fprintf('\\nInitializing excitation object...\\n');
"""
    
        if excitation_type == 'planewave':
            code += """% Plane wave excitation (ALL polarizations at once)
exc = planewave(pol, dir, op);
fprintf('  [OK] Plane wave excitation initialized\\n');
fprintf('    - Polarizations: %d\\n', size(pol, 1));
fprintf('    - Propagation directions: %d\\n', size(dir, 1));
"""
        elif excitation_type == 'dipole':
            code += """pt = compoint(p, dip_pos, op);
exc = dipole(pt, dip_mom, op);
fprintf('  [OK] Dipole excitation initialized\\n');
"""
        elif excitation_type == 'eels':
            code += """exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
fprintf('  [OK] EELS excitation initialized\\n');
"""
    
        code += """
% Start timer
calculation_start = tic;

"""
    
        # Generate loop - parfor if parallel enabled, regular for otherwise
        if use_parallel:
            code += """% ========================================
% PARALLEL EXECUTION (parfor loop)
% ========================================
if exist('parallel_enabled', 'var') && parallel_enabled
    fprintf('\\n Using PARALLEL execution (parfor loop)\\n');
    fprintf('    Progress updates may appear out of order\\n');
    fprintf('    Each worker computes independently\\n\\n');
    
    %% PARALLEL LOOP (FIXED!)
    % - Excitation object (exc) is already initialized
    % - MNPBEM processes ALL polarizations at once
    % - No need for inner polarization loop
    parfor ien = 1:n_wavelengths
        try
            % Progress indicator (less frequent for parallel)
            if mod(ien-1, max(1, floor(n_wavelengths/10))) == 0
                fprintf('  [Worker] Processing wavelength %d/%d (lambda = %.1f nm)\\n', ...
                        ien, n_wavelengths, enei(ien));
            end
            
            % FIXED: Just use pre-initialized exc object!
            % MNPBEM automatically handles ALL polarizations in one call
            sig = bem \\ exc(p, enei(ien));
            
            % Extract cross sections (returns vector for all polarizations)
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            % Error handling: print error but continue with other wavelengths
            fprintf('  ERROR at wavelength %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            % Leave zeros for this wavelength
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
    end
    
    fprintf('\\n[OK] Parallel computation completed\\n');
    
else
    % ========================================
    % SERIAL EXECUTION (for loop)
    % ========================================
    fprintf('\\n Using SERIAL execution (for loop)\\n\\n');
"""
        else:
            # Serial execution only
            code += """% ========================================
% SERIAL EXECUTION (for loop)
% ========================================
fprintf('\\nStarting wavelength loop (serial execution)...\\n\\n');
"""
    
        # FIXED: Serial loop without polarization loop
        code += """
    % Progress bar
    multiWaitbar('BEM Calculation', 0, 'Color', 'g', 'CanCancel', 'on');
    
    %% SERIAL LOOP (FIXED!)
    for ien = 1:n_wavelengths
        % Update progress bar
        multiWaitbar('BEM Calculation', ien / n_wavelengths);
        
        % Text progress indicator
        if mod(ien-1, max(1, floor(n_wavelengths/20))) == 0
            fprintf('  Progress: %d/%d (lambda = %.1f nm, %.1f%%)\\n', ...
                    ien, n_wavelengths, enei(ien), 100*ien/n_wavelengths);
        end
        
        try
            % FIXED: Use pre-initialized exc object
            % MNPBEM handles ALL polarizations automatically
            sig = bem \\ exc(p, enei(ien));
            
            % Extract cross sections (vector for all polarizations)
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            fprintf('  [!] ERROR at wavelength %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
"""

        if calculate_fields:
            code += self._generate_field_calculation_in_loop()

        code += """    end

    % Close waitbar
    multiWaitbar('CloseAll');
    fprintf('\\n[OK] Serial computation completed\\n');
"""
        
        if use_parallel:
            code += """end  % End of parallel/serial decision
"""
        
        # Timing
        code += """
% Calculation timing
calculation_time = toc(calculation_start);
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Calculation completed in %.2f seconds (%.2f minutes)\\n', ...
        calculation_time, calculation_time/60);
fprintf('Average time per wavelength: %.2f seconds\\n', ...
        calculation_time / n_wavelengths);
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_field_setup(self):
        """Generate field mesh setup - AFTER greentab."""
        use_substrate = self.config.get('use_substrate', False)
        use_mirror = self.config.get('use_mirror_symmetry', False)

        code = """
%% Field Calculation Setup
fprintf('\\nSetting up field calculation mesh...\\n');
"""

        # Add mirror expansion for field calculation
        if use_mirror:
            code += """
% Mirror symmetry: Expand to full particle for field calculation
fprintf('  Expanding mirror particle to full size for field calculation...\\n');
p_field = full(p);
fprintf('  [OK] Full particle: %d boundary elements\\n', p_field.n);
"""
        else:
            code += """
% Use particle as-is for field calculation
p_field = p;
"""

        code += """
% Select wavelength for field calculation
"""

        field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
        
        if field_wl_idx == 'middle':
            code += """% Use middle wavelength (single wavelength for all polarizations)
field_wavelength_idx = round(n_wavelengths / 2);
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
"""
        elif field_wl_idx == 'peak':
            code += """% Find absorption peak wavelength for EACH polarization
fprintf('  Finding absorption peak for each polarization...\\n');

% Find max absorption wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_abs_pol, idx] = max(abs_cross(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('    Pol %d: Peak absorption %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_abs_pol, enei(idx), idx);
end

% ============================================================
% UNPOLARIZED PEAK WAVELENGTH CALCULATION
% ============================================================
% Check if polarizations are orthogonal for unpolarized calculation
unpolarized_peak_idx = -1;  % -1 means no unpolarized calculation

if n_polarizations == 2
    % Check orthogonality for plane wave (2 polarizations)
    pol1 = pol(1, :) / norm(pol(1, :));
    pol2 = pol(2, :) / norm(pol(2, :));
    dot_prod = abs(dot(pol1, pol2));

    if dot_prod < 1e-6
        fprintf('  [Unpolarized] Two orthogonal polarizations detected\\n');

        % Calculate unpolarized spectrum (average)
        unpol_abs = mean(abs_cross, 2);
        [unpol_max_abs, unpolarized_peak_idx] = max(unpol_abs);

        fprintf('  [Unpolarized] Peak absorption: %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
                unpol_max_abs, enei(unpolarized_peak_idx), unpolarized_peak_idx);
    end
elseif n_polarizations == 3
    % Check orthogonality for dipole (3 directions)
    pol1 = pol(1, :) / norm(pol(1, :));
    pol2 = pol(2, :) / norm(pol(2, :));
    pol3 = pol(3, :) / norm(pol(3, :));

    dot12 = abs(dot(pol1, pol2));
    dot23 = abs(dot(pol2, pol3));
    dot13 = abs(dot(pol1, pol3));

    if dot12 < 1e-6 && dot23 < 1e-6 && dot13 < 1e-6
        fprintf('  [Unpolarized] Three orthogonal directions detected\\n');

        % Calculate unpolarized spectrum (average)
        unpol_abs = mean(abs_cross, 2);
        [unpol_max_abs, unpolarized_peak_idx] = max(unpol_abs);

        fprintf('  [Unpolarized] Peak absorption: %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
                unpol_max_abs, enei(unpolarized_peak_idx), unpolarized_peak_idx);
    end
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);

% Add unpolarized peak if different from existing peaks
if unpolarized_peak_idx > 0 && ~ismember(unpolarized_peak_idx, unique_field_wavelength_indices)
    unique_field_wavelength_indices = sort([unique_field_wavelength_indices, unpolarized_peak_idx]);
    fprintf('  [Unpolarized] Added unpolarized peak wavelength to field calculation list\\n');
end

n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
for iw = 1:n_field_wavelengths
    idx = unique_field_wavelength_indices(iw);
    pols_at_this_wl = find(field_wavelength_indices == idx);

    % Check if this is the unpolarized peak
    if idx == unpolarized_peak_idx
        fprintf('     lambda = %.1f nm (index %d): UNPOLARIZED PEAK -> all polarizations\\n', ...
                enei(idx), idx);
    else
        fprintf('     lambda = %.1f nm (index %d): polarizations [%s]\\n', ...
                enei(idx), idx, num2str(pols_at_this_wl));
    end
end
"""
        elif field_wl_idx == 'peak_ext':
            code += """% Find extinction peak wavelength for EACH polarization
fprintf('  Finding extinction peak for each polarization...\\n');

% Find max extinction wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_ext_pol, idx] = max(ext(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('    Pol %d: Peak extinction %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_ext_pol, enei(idx), idx);
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
        elif field_wl_idx == 'peak_sca':
            code += """% Find scattering peak wavelength for EACH polarization
fprintf('  Finding scattering peak for each polarization...\\n');

% Find max scattering wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_sca_pol, idx] = max(sca(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('    Pol %d: Peak scattering %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_sca_pol, enei(idx), idx);
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
        elif isinstance(field_wl_idx, int):
            code += f"""% Use specified wavelength index (single wavelength for all polarizations)
field_wavelength_idx = {field_wl_idx};
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
"""
        elif isinstance(field_wl_idx, list):
            # List of wavelength values (nm) - map to nearest indices
            wl_list_str = ', '.join([str(wl) for wl in field_wl_idx])
            code += f"""% Use specified wavelength list (nm) - map to nearest indices
target_wavelengths = [{wl_list_str}];  % Target wavelengths in nm
fprintf('  Mapping %d target wavelengths to nearest indices...\\n', length(target_wavelengths));

% Map each target wavelength to nearest index in enei
unique_field_wavelength_indices = zeros(1, length(target_wavelengths));
for iwl = 1:length(target_wavelengths)
    [~, nearest_idx] = min(abs(enei - target_wavelengths(iwl)));
    unique_field_wavelength_indices(iwl) = nearest_idx;
    fprintf('    Target %.1f nm -> index %d (actual %.1f nm)\\n', ...
            target_wavelengths(iwl), nearest_idx, enei(nearest_idx));
end

% Remove duplicates and sort
unique_field_wavelength_indices = unique(unique_field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

% For each wavelength, calculate all polarizations
field_wavelength_indices = unique_field_wavelength_indices;  % All pols at each wavelength

fprintf('  -> %d unique wavelength indices after deduplication\\n', n_field_wavelengths);
"""
        else:
            code += """% Default: use middle wavelength (single wavelength for all polarizations)
field_wavelength_idx = round(n_wavelengths / 2);
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
"""
        
        code += """
fprintf('Field calculation at %d wavelength(s):\\n', n_field_wavelengths);
for iw = 1:n_field_wavelengths
    fprintf('  [%d] lambda = %.1f nm (index %d)\\n', ...
            iw, enei(unique_field_wavelength_indices(iw)), unique_field_wavelength_indices(iw));
end

"""
    
        if use_substrate:
            mindist = self.config.get('field_mindist', 0.5)
            nmax = self.config.get('field_nmax', 2000)
            
            code += f"""% Substrate mode: meshfield with pre-computed greentab
% Reshape grids back to original shape
x_grid = reshape(x_grid, grid_shape);
y_grid = reshape(y_grid, grid_shape);
z_grid = reshape(z_grid, grid_shape);

% Create meshfield using op with greentab
fprintf('  Creating meshfield...\\n');
field_mindist = {mindist};  % Store mindist for later use
emesh = meshfield(p_field, x_grid, y_grid, z_grid, op, ...
                  'mindist', field_mindist, 'nmax', {nmax});
fprintf('  [OK] Meshfield ready with %d points\\n', emesh.pt.n);
"""
        else:
            # Standard non-substrate field setup
            field_region = self.config.get('field_region', {})
            mindist = self.config.get('field_mindist', 0.2)
            nmax = self.config.get('field_nmax', 2000)
            x_range = field_region.get('x_range', [-50, 50, 101])
            y_range = field_region.get('y_range', [0, 0, 1])
            z_range = field_region.get('z_range', [0, 0, 1])
            
            if y_range[2] == 1:  # xz-plane
                code += f"""% Create field grid: xz-plane
x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
            elif z_range[2] == 1:  # xy-plane
                code += f"""% Create field grid: xy-plane
x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
        
            code += f"""
% Create meshfield
field_mindist = {mindist};  % Store mindist for later use
emesh = meshfield(p_field, x_grid, y_grid, z_grid, op, ...
                  'mindist', field_mindist, 'nmax', {nmax});
fprintf('  [OK] Meshfield created: %d points\\n', numel(x_grid));
"""

        code += """
% CRITICAL: Store grid shape for reshape operations
grid_shape = size(x_grid);

% Initialize field data storage - will store data for each (wavelength, polarization) pair
field_data = struct('wavelength', {}, 'wavelength_idx', {}, 'polarization', {}, ...
                    'polarization_idx', {}, 'e_total', {}, 'enhancement', {}, ...
                    'intensity', {}, 'x_grid', {}, 'y_grid', {}, 'z_grid', {});
field_data_idx = 0;  % Counter for field_data entries

% Initialize surface charge storage
surface_charge = struct();
"""
    
        return code
    
    def _generate_field_calculation_in_loop(self):
        """Generate field calculation - fixed dimension handling and excitation type."""
        excitation_type = self.config['excitation_type']
        
        code = """
        % Calculate fields at selected wavelength(s) - check if current wavelength is one of the targets
        if ismember(ien, unique_field_wavelength_indices)
            fprintf('\\n  -> Calculating fields at lambda = %.1f nm (index %d)...\\n', enei(ien), ien);
            field_calc_start = tic;

            % Find which polarizations have their peak at this wavelength
            % For unpolarized peak wavelength, calculate ALL polarizations
            if exist('unpolarized_peak_idx', 'var') && ien == unpolarized_peak_idx
                pols_at_this_wl = 1:n_polarizations;
                fprintf('    [UNPOLARIZED PEAK] Calculating ALL polarizations: [%s]\\n', num2str(pols_at_this_wl));
            else
                pols_at_this_wl = find(field_wavelength_indices == ien);
                fprintf('    Polarizations with peak at this wavelength: [%s]\\n', num2str(pols_at_this_wl));
            end

            fprintf('  Computing induced fields...\\n');
            % Mirror symmetry: expand surface charges to full particle
            if use_mirror
                sig_field = full(sig);
            else
                sig_field = sig;
            end
            e_induced_obj = emesh(sig_field);

            % Extract numeric array from field object
            if isobject(e_induced_obj) || isstruct(e_induced_obj)
                if isfield(e_induced_obj, 'e') || isprop(e_induced_obj, 'e')
                    e_induced_all = e_induced_obj.e;
                elseif isfield(e_induced_obj, 'val') || isprop(e_induced_obj, 'val')
                    e_induced_all = e_induced_obj.val;
                else
                    e_induced_all = double(e_induced_obj);
                end
            else
                e_induced_all = e_induced_obj;
            end

            grid_shape = size(x_grid);

            % Process polarizations for this wavelength
            for ipol_loop = 1:length(pols_at_this_wl)
                ipol = pols_at_this_wl(ipol_loop);
                fprintf('    Processing polarization %d...\\n', ipol);

"""
        
        if excitation_type == 'planewave':
            code += """                % Create single-polarization plane wave excitation
                exc_single = planewave(pol(ipol, :), dir(ipol, :), op);
"""
        elif excitation_type == 'dipole':
            code += """                % Dipole excitation
                pt_single = compoint(p, dip_pos, op);
                exc_single = dipole(pt_single, dip_mom, op);
"""
        elif excitation_type == 'eels':
            code += """                % EELS excitation
                exc_single = eelsret(p, impact, beam_energy, 'width', beam_width, op);
"""
        
        code += """
                % Extract induced field for this polarization
                if n_polarizations > 1
                    e_induced = e_induced_all(:, :, ipol);
                else
                    e_induced = e_induced_all;
                end
                fprintf('      e_induced size: [%s]\\n', num2str(size(e_induced)));

                % Calculate incoming field for this polarization
                e_incoming_obj = exc_single.field(emesh.pt, enei(ien));

                % Extract numeric array from field object
                if isobject(e_incoming_obj) || isstruct(e_incoming_obj)
                    if isfield(e_incoming_obj, 'e') || isprop(e_incoming_obj, 'e')
                        e_incoming = e_incoming_obj.e;
                    elseif isfield(e_incoming_obj, 'val') || isprop(e_incoming_obj, 'val')
                        e_incoming = e_incoming_obj.val;
                    else
                        e_incoming = double(e_incoming_obj);
                    end
                else
                    e_incoming = e_incoming_obj;
                end
                fprintf('      e_incoming size: [%s]\\n', num2str(size(e_incoming)));

                % Ensure 2D arrays for addition
                if ndims(e_induced) == 3
                    e_induced = squeeze(e_induced);
                end
                if ndims(e_incoming) == 3
                    e_incoming = squeeze(e_incoming);
                end

                % Handle size mismatch
                sz_induced = size(e_induced);
                sz_incoming = size(e_incoming);

                if ~isequal(sz_induced, sz_incoming)
                    fprintf('    [!] Size mismatch: e_induced [%s], e_incoming [%s]\\n', ...
                            num2str(sz_induced), num2str(sz_incoming));

                    if isequal(sz_induced, fliplr(sz_incoming))
                        e_incoming = e_incoming.';
                    elseif numel(e_induced) == numel(e_incoming)
                        e_incoming = reshape(e_incoming, size(e_induced));
                    elseif sz_induced(1) == sz_incoming(1)
                        if sz_incoming(2) > sz_induced(2)
                            e_incoming = e_incoming(:, 1:sz_induced(2));
                        elseif sz_induced(2) > sz_incoming(2)
                            e_induced = e_induced(:, 1:sz_incoming(2));
                        end
                    end
                    fprintf('    -> Fixed sizes: e_induced [%s], e_incoming [%s]\\n', ...
                            num2str(size(e_induced)), num2str(size(e_incoming)));
                end

                % Total field
                e_total = e_induced + e_incoming;

                % Calculate field and intensity enhancement
                e_mag_sq = dot(e_total, e_total, 2);         % |E|²
                e0_mag_sq = dot(e_incoming, e_incoming, 2);  % |E0|²
                enhancement = sqrt(e_mag_sq ./ e0_mag_sq);   % |E/E0| (field enhancement)
                e_intensity = e_mag_sq ./ e0_mag_sq;         % |E|²/|E0|² (intensity enhancement)
                
                % Handle meshfield point filtering (mindist option)
                % meshfield removes points too close to particle surface
                n_grid_points = numel(x_grid);
                n_field_points = length(enhancement);
                
                if n_field_points < n_grid_points
                    % Points were filtered - create full grid with NaN
                    fprintf('    -> Grid filtering: %d/%d points used (mindist=%.2f nm)\\n', ...
                            n_field_points, n_grid_points, field_mindist);

                    % Create NaN-filled arrays for scalars and vectors
                    enhancement_full = nan(n_grid_points, 1);
                    e_intensity_full = nan(n_grid_points, 1);
                    e_mag_sq_full = nan(n_grid_points, 1);    % |E|² for energy ratio
                    e0_mag_sq_full = nan(n_grid_points, 1);   % |E0|² for energy ratio
                    e_total_full = nan(n_grid_points, 3);  % Vector field (Ex, Ey, Ez)

                    % Fill valid points using meshfield indices
                    if exist('emesh_ind', 'var') && ~isempty(emesh_ind)
                        enhancement_full(emesh_ind) = enhancement;
                        e_intensity_full(emesh_ind) = e_intensity;
                        e_mag_sq_full(emesh_ind) = e_mag_sq;
                        e0_mag_sq_full(emesh_ind) = e0_mag_sq;
                        e_total_full(emesh_ind, :) = e_total;
                    else
                        % Fallback: match by coordinates using exact axis matching
                        fprintf('    [!] Warning: emesh_ind not found, using exact axis matching\\n');

                        % Get unique axis values for proper grid mapping
                        x_vec = unique(x_grid);
                        y_vec = unique(y_grid);
                        z_vec = unique(z_grid);

                        % Determine plane type and use appropriate matching
                        if numel(y_vec) == 1
                            % xz-plane: y is constant
                            fprintf('      Grid type: xz-plane\\n');
                            for ii = 1:n_field_points
                                [~, ix] = min(abs(emesh.pt.pos(ii,1) - x_vec));
                                [~, iz] = min(abs(emesh.pt.pos(ii,3) - z_vec));
                                idx = sub2ind(grid_shape, iz, ix);
                                enhancement_full(idx) = enhancement(ii);
                                e_intensity_full(idx) = e_intensity(ii);
                                e_mag_sq_full(idx) = e_mag_sq(ii);
                                e0_mag_sq_full(idx) = e0_mag_sq(ii);
                                e_total_full(idx, :) = e_total(ii, :);
                            end
                        elseif numel(z_vec) == 1
                            % xy-plane: z is constant
                            fprintf('      Grid type: xy-plane\\n');
                            for ii = 1:n_field_points
                                [~, ix] = min(abs(emesh.pt.pos(ii,1) - x_vec));
                                [~, iy] = min(abs(emesh.pt.pos(ii,2) - y_vec));
                                idx = sub2ind(grid_shape, iy, ix);
                                enhancement_full(idx) = enhancement(ii);
                                e_intensity_full(idx) = e_intensity(ii);
                                e_mag_sq_full(idx) = e_mag_sq(ii);
                                e0_mag_sq_full(idx) = e0_mag_sq(ii);
                                e_total_full(idx, :) = e_total(ii, :);
                            end
                        elseif numel(x_vec) == 1
                            % yz-plane: x is constant
                            fprintf('      Grid type: yz-plane\\n');
                            for ii = 1:n_field_points
                                [~, iy] = min(abs(emesh.pt.pos(ii,2) - y_vec));
                                [~, iz] = min(abs(emesh.pt.pos(ii,3) - z_vec));
                                idx = sub2ind(grid_shape, iz, iy);
                                enhancement_full(idx) = enhancement(ii);
                                e_intensity_full(idx) = e_intensity(ii);
                                e_mag_sq_full(idx) = e_mag_sq(ii);
                                e0_mag_sq_full(idx) = e0_mag_sq(ii);
                                e_total_full(idx, :) = e_total(ii, :);
                            end
                        else
                            % 3D grid: fallback to flattened coordinate matching
                            fprintf('      Grid type: 3D (using coordinate matching)\\n');
                            x_flat = x_grid(:);
                            y_flat = y_grid(:);
                            z_flat = z_grid(:);
                            for ii = 1:n_field_points
                                dx = abs(x_flat - emesh.pt.pos(ii,1));
                                dy = abs(y_flat - emesh.pt.pos(ii,2));
                                dz = abs(z_flat - emesh.pt.pos(ii,3));
                                [~, idx] = min(dx + dy + dz);
                                enhancement_full(idx) = enhancement(ii);
                                e_intensity_full(idx) = e_intensity(ii);
                                e_mag_sq_full(idx) = e_mag_sq(ii);
                                e0_mag_sq_full(idx) = e0_mag_sq(ii);
                                e_total_full(idx, :) = e_total(ii, :);
                            end
                        end
                    end

                    enhancement = enhancement_full;
                    e_intensity = e_intensity_full;
                    e_mag_sq = e_mag_sq_full;
                    e0_mag_sq = e0_mag_sq_full;
                    e_total = e_total_full;
                end
                
                % Now safely reshape
                enhancement = reshape(enhancement, grid_shape);
                e_intensity = reshape(e_intensity, grid_shape);

                % Reshape e_total to [ny, nx, 3] for vector field
                if numel(grid_shape) == 2
                    e_total = reshape(e_total, [grid_shape(1), grid_shape(2), 3]);
                end

                % Reshape e_sq and e0_sq for energy ratio calculation
                e_sq_grid = reshape(e_mag_sq, grid_shape);      % |E|² (raw intensity)
                e0_sq_grid = reshape(e0_mag_sq, grid_shape);    % |E0|² (reference intensity)

                % Store with wavelength and polarization indices
                field_data_idx = field_data_idx + 1;
                field_data(field_data_idx).wavelength = enei(ien);
                field_data(field_data_idx).wavelength_idx = ien;
                field_data(field_data_idx).polarization = pol(ipol, :);
                field_data(field_data_idx).polarization_idx = ipol;
                field_data(field_data_idx).e_total = e_total;
                field_data(field_data_idx).enhancement = enhancement;  % |E/E0| (field enhancement)
                field_data(field_data_idx).intensity = e_intensity;    % |E|²/|E0|² (intensity enhancement)
                field_data(field_data_idx).e_sq = e_sq_grid;           % |E|² (raw intensity)
                field_data(field_data_idx).e0_sq = e0_sq_grid;         % |E0|² (reference intensity)
                field_data(field_data_idx).x_grid = x_grid;
                field_data(field_data_idx).y_grid = y_grid;
                field_data(field_data_idx).z_grid = z_grid;

                fprintf('      -> Stored as field_data(%d): lambda=%.1f nm, pol=%d\\n', ...
                        field_data_idx, enei(ien), ipol);

                %% SAVE SURFACE CHARGE (for plasmon mode analysis)
                % Extract surface charge from BEM solution
                % Note: sig_field contains full particle data (expanded if mirror symmetry)
                charge_values_all = [];
                extraction_method = '';

                % Method 1: Check if it's already numeric
                if isnumeric(sig_field)
                    charge_values_all = sig_field;
                    extraction_method = 'numeric';

                % Method 2: Try .sig1 field (MNPBEM compstruct object - particle 1)
                elseif (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'sig1') || isprop(sig_field, 'sig1'))
                    try
                        charge_values_all = sig_field.sig1;
                        extraction_method = '.sig1 (compstruct)';
                    catch
                    end

                % Method 3: Try .sig2 field (MNPBEM compstruct object - particle 2)
                elseif isempty(charge_values_all) && (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'sig2') || isprop(sig_field, 'sig2'))
                    try
                        charge_values_all = sig_field.sig2;
                        extraction_method = '.sig2 (compstruct)';
                    catch
                    end

                % Method 4: Try .sig field (older MNPBEM bemsolve object)
                elseif (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'sig') || isprop(sig_field, 'sig'))
                    try
                        charge_values_all = sig_field.sig;
                        extraction_method = '.sig';
                    catch
                    end

                % Method 5: Try .val field (alternative MNPBEM format)
                elseif (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'val') || isprop(sig_field, 'val'))
                    try
                        charge_values_all = sig_field.val;
                        extraction_method = '.val';
                    catch
                    end

                % Method 6: Try full() for sparse matrices
                elseif issparse(sig_field)
                    try
                        charge_values_all = full(sig_field);
                        extraction_method = 'full()';
                    catch
                    end

                % Method 7: Try double() conversion
                else
                    try
                        charge_values_all = double(sig_field);
                        extraction_method = 'double()';
                    catch
                    end
                end

                % Method 8: Try subsref (:) if still empty
                if isempty(charge_values_all)
                    try
                        charge_values_all = sig_field(:);
                        if isnumeric(charge_values_all) && ~isempty(charge_values_all)
                            extraction_method = 'subsref(:)';
                        else
                            charge_values_all = [];
                        end
                    catch
                    end
                end

                % Log extraction result
                if ~isempty(charge_values_all)
                    fprintf('      → Surface charge extracted via %s: size [%s]\\n', extraction_method, num2str(size(charge_values_all)));
                else
                    fprintf('      [WARNING] Could not extract surface charge from sig_field\\n');
                    fprintf('      [DEBUG] class=%s, size=[%s], isobj=%d, struct=%d, numeric=%d, sparse=%d\\n', ...
                            class(sig_field), num2str(size(sig_field)), ...
                            isobject(sig_field), isstruct(sig_field), isnumeric(sig_field), issparse(sig_field));
                    if isobject(sig_field) || isstruct(sig_field)
                        try
                            fn = fieldnames(sig_field);
                            fprintf('      [DEBUG] Available fields (%d): %s\\n', length(fn), strjoin(fn(1:min(10,end)), ', '));
                        catch
                        end
                    end
                end

                % Only save if charge extraction succeeded
                if ~isempty(charge_values_all)
                    % Select polarization column
                    if size(charge_values_all, 2) >= ipol
                        charge_values = charge_values_all(:, ipol);
                    else
                        charge_values = charge_values_all(:, 1);
                    end

                    % Store surface charge data (same index as field_data for consistency)
                    % Note: p_field contains full particle geometry (expanded if mirror symmetry)
                    surface_charge(field_data_idx).wavelength = enei(ien);
                    surface_charge(field_data_idx).wavelength_idx = ien;
                    surface_charge(field_data_idx).polarization = pol(ipol, :);
                    surface_charge(field_data_idx).polarization_idx = ipol;
                    surface_charge(field_data_idx).vertices = p_field.verts;      % Vertex coordinates
                    surface_charge(field_data_idx).faces = p_field.faces;         % Face connectivity
                    surface_charge(field_data_idx).centroids = p_field.pos;       % Face centers
                    surface_charge(field_data_idx).normals = p_field.nvec;        % Face normals
                    surface_charge(field_data_idx).areas = p_field.area;          % Face areas
                    surface_charge(field_data_idx).charge = charge_values;  % Surface charge values

                    fprintf('      -> Stored surface_charge(%d): %d faces, %d vertices\\n', ...
                            field_data_idx, size(p_field.faces, 1), size(p_field.verts, 1));
                else
                    fprintf('      -> Surface charge extraction failed, skipping...\\n');
                end
            end

            field_calc_time = toc(field_calc_start);
            fprintf('\\n[OK] Field calculation at lambda=%.1f nm completed in %.2f seconds\\n', ...
                    enei(ien), field_calc_time);
            fprintf('================================================================\\n');

            % Update total calculation time
            calculation_time = calculation_time + field_calc_time;
        end
"""

        return code

    def _generate_save_results(self):
        """Generate code to save simulation results."""
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = """
%% Save Results
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Saving results...\\n');

results = struct();
results.wavelength = enei;
results.scattering = sca;
results.extinction = ext;
results.absorption = abs_cross;
results.polarizations = pol;
results.propagation_dirs = dir;
results.calculation_time = calculation_time;
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    results.fields = field_data;
    fprintf('Field data included in results\\n');
end

if exist('surface_charge', 'var') && ~isempty(surface_charge)
    results.surface_charge = surface_charge;
    fprintf('Surface charge data included in results\\n');
end
"""
        
        code += """
save('simulation_results.mat', 'results');
fprintf('[OK] Results saved to: simulation_results.mat\\n');

% Save cross sections to text file
fid = fopen('simulation_results.txt', 'w');
fprintf(fid, 'Wavelength(nm)\\t');
for ipol = 1:n_polarizations
    fprintf(fid, 'Sca_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    fprintf(fid, 'Ext_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    if ipol < n_polarizations
        fprintf(fid, 'Abs_pol%d\\t', ipol);
    else
        fprintf(fid, 'Abs_pol%d', ipol);
    end
end
fprintf(fid, '\\n');

for i = 1:length(enei)
    fprintf(fid, '%.2f\\t', enei(i));
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', sca(i, ipol));
    end
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', ext(i, ipol));
    end
    for ipol = 1:n_polarizations
        if ipol < n_polarizations
            fprintf(fid, '%.6e\\t', abs_cross(i, ipol));
        else
            fprintf(fid, '%.6e', abs_cross(i, ipol));
        end
    end
    fprintf(fid, '\\n');
end
fclose(fid);
fprintf('[OK] Cross sections saved to: simulation_results.txt\\n');
"""

        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    save('field_data.mat', 'field_data', '-v7.3');
    fprintf('[OK] Field data saved to: field_data.mat\\n');
end
"""
        
        code += """
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_footer(self):
        """
        Generate safe cleanup and exit code.
        
        CRITICAL FIXES:
        1. File verification BEFORE clearing variables (prevents index error)
        2. Safe try-catch for dir() with numel() check
        3. Waitbar cleanup first to prevent ^H characters
        4. Improved parallel cleanup with longer timeout
        """
        use_parallel = self.config.get('use_parallel', False)
        
        code = """
%% Cleanup and Exit
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Cleaning up...\\n');

"""

        # Add parallel cleanup if parallel was enabled
        if use_parallel:
            code += self._generate_parallel_cleanup()
        
        code += """
% Close all waitbars FIRST (to prevent ^H characters in output)
try
    multiWaitbar('CloseAll');
    fprintf('  [OK] Closed all waitbars\\n');
catch
    % multiWaitbar not used or already closed
end

% Close all figures
close all;
fprintf('  [OK] Closed all figures\\n');

% CRITICAL: Close all file handles AND force sync to disk
fclose('all');
fprintf('  [OK] Closed all file handles\\n');

% ========================================
% IMPORTANT: Verify files BEFORE clearing variables!
% ========================================
if exist('field_data.mat', 'file')
    fprintf('  -> Verifying field_data.mat...\\n');
    try
        file_info = dir('field_data.mat');
        % SAFE: Check both isempty and numel
        if ~isempty(file_info) && numel(file_info) >= 1
            fprintf('    File size: %.2f MB\\n', file_info(1).bytes / 1024 / 1024);
        else
            fprintf('    Warning: File exists but dir() returned empty\\n');
        end
    catch ME
        fprintf('    Warning: Could not verify file: %s\\n', ME.message);
    end
end

if exist('simulation_results.mat', 'file')
    fprintf('  -> Verifying simulation_results.mat...\\n');
    try
        file_info = dir('simulation_results.mat');
        if ~isempty(file_info) && numel(file_info) >= 1
            fprintf('    File size: %.2f MB\\n', file_info(1).bytes / 1024 / 1024);
        end
    catch ME
        fprintf('    Warning: Could not verify file: %s\\n', ME.message);
    end
end

% Clear large variables to free memory (AFTER file verification)
clear bem sig field_data meshfield e_induced e_incoming e_total enhancement;
fprintf('  [OK] Cleared temporary variables\\n');

fprintf('================================================================\\n');
fprintf('\\n');
fprintf('=== MNPBEM Simulation Completed Successfully ===\\n');
fprintf('\\n');

%% Safe Exit Sequence
fprintf('Preparing to exit MATLAB...\\n');

% IMPROVED: Longer pause for I/O completion (5 seconds instead of 3)
fprintf('  Waiting for all I/O operations to complete...\\n');
pause(5);

% Turn off diary if it was on
try
    diary off;
catch
    % Ignore if diary wasn't on
end

% Safe exit
fprintf('Exiting MATLAB now.\\n');
fprintf('\\n');

% FIXED: Use 'exit' instead of invalid 'quit force'
exit;
"""
        return code
    
    def _python_list_to_matlab(self, python_list):
        """Convert Python list to MATLAB array string."""
        if not python_list:
            return '[]'
        
        if isinstance(python_list[0], (list, tuple)):
            rows = []
            for row in python_list:
                row_str = ', '.join([str(x) for x in row])
                rows.append(row_str)
            return '[' + '; '.join(rows) + ']'
        else:
            return '[' + ', '.join([str(x) for x in python_list]) + ']'

    def _extract_closed_args(self, material_code):
        """Extract closed arguments from material code."""
        # Find: closed = [1, 2];
        if 'closed = [' in material_code:
            start = material_code.find('closed = [') + len('closed = [')
            end = material_code.find(']', start)
            self._closed_args = material_code[start:end].strip()
        else:
            # Single value: closed = 1;
            if 'closed = ' in material_code:
                start = material_code.find('closed = ') + len('closed = ')
                end = material_code.find(';', start)
                self._closed_args = material_code[start:end].strip()
            else:
                self._closed_args = "1"

    def _generate_wavelength_loop_with_chunking(self):
        """
        Wavelength loop with memory-efficient chunking AND field calculation support.
        
        OPTION 1: UNIVERSAL REFERENCE METHOD
        
        Enhancement calculation uses incoming field as if ALL grid points are in
        external medium (what the field would be without the particle).
        
        This is the RECOMMENDED and most physically meaningful approach:
        - Internal enhancement = |E_internal|² / |E0_reference|²
        - E0_reference = plane wave field in vacuum/embedding medium
        - Same reference for external AND internal points
        
        FIXED BUGS:
        - pt_internal.pc → pt_internal (compoint returns point object directly)
        - 4D array handling for grid-based field calculations
        - NaN filtering after reshape (meshfield mindist filtering)
        - 3D array slicing condition: size(...,3) == n_polarizations (not > 3)
        - Enhancement calculation threshold (prevents Inf/NaN)
        - Changed to INTENSITY enhancement: |E|²/|E0|² (not field magnitude)
        - CRITICAL: Universal reference field for all points (prevents internal = 0 bug!)
        
        Strategy: 
        1. Calculate ALL cross sections first (no field in loop)
        2. Find peak AFTER all chunks complete
        3. Calculate field separately for peak wavelength (internal + external)
        4. Use universal reference in external medium for enhancement
        """
        
        wavelength_range = self.config['wavelength_range']
        chunk_size = self.config.get('wavelength_chunk_size', 20)
        use_parallel = self.config.get('use_parallel', False)
        use_iterative = self.config.get('use_iterative_solver', False)
        excitation_type = self.config['excitation_type']
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = f"""
%% Wavelength Loop with Chunking (Memory-Efficient!)
if ~exist('enei', 'var')
    enei = linspace({wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]});
end

n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

% Chunking setup
chunk_size = {chunk_size};
n_chunks = ceil(n_wavelengths / chunk_size);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('     Starting BEM Calculation with Wavelength Chunking         \\n');
fprintf('================================================================\\n');
fprintf('Total wavelengths: %d\\n', n_wavelengths);
fprintf('Chunk size: %d wavelengths\\n', chunk_size);
fprintf('Number of chunks: %d\\n', n_chunks);
"""

        if use_iterative:
            code += """fprintf('Solver mode: ITERATIVE (H-matrix compression, ~14%% memory)\\n');
"""
        else:
            code += """fprintf('Solver mode: DIRECT (full matrix)\\n');
"""
        
        code += """fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""

        # Parallel setup
        if use_parallel:
            code += self._generate_parallel_setup()
        
        # Excitation initialization
        code += """
%% Initialize Excitation (once, outside all loops!)
fprintf('\\nInitializing excitation object...\\n');
"""

        if excitation_type == 'planewave':
            code += """exc = planewave(pol, dir, op);
fprintf('  [OK] Plane wave excitation initialized\\n');
"""
        elif excitation_type == 'dipole':
            code += """pt = compoint(p, dip_pos, op);
exc = dipole(pt, dip_mom, op);
fprintf('  [OK] Dipole excitation initialized\\n');
"""
        elif excitation_type == 'eels':
            code += """exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
fprintf('  [OK] EELS excitation initialized\\n');
"""

        code += """
% Start overall timer
total_start = tic;

%% ========================================
%% CHUNK LOOP: Calculate cross sections ONLY (NO field calculation)
%% ========================================
for ichunk = 1:n_chunks
    % Calculate wavelength indices for this chunk
    idx_start = (ichunk-1) * chunk_size + 1;
    idx_end = min(ichunk * chunk_size, n_wavelengths);
    chunk_indices = idx_start:idx_end;
    n_chunk = length(chunk_indices);
    
    fprintf('\\n');
    fprintf('================================================================\\n');
    fprintf('  Processing Chunk %d/%d: wavelengths %d-%d (%d points)\\n', ...
            ichunk, n_chunks, idx_start, idx_end, n_chunk);
    fprintf('  lambda range: %.1f - %.1f nm\\n', ...
            enei(idx_start), enei(idx_end));
    fprintf('================================================================\\n');
    
    chunk_start = tic;

    % CRITICAL: Clear BEM solver between chunks for memory efficiency
    % Reinitialize BEM solver to release memory (works for both mirror and non-mirror)
    if ichunk > 1
        fprintf('  -> Reinitializing BEM solver...\\n');
        bem = bemsolver(p, op);
        fprintf('  [OK] BEM solver reinitialized\\n');
    end

"""

        if use_parallel:
            # Parallel execution (works with both Direct and Iterative)
            code += """    % ========================================
    % PARALLEL EXECUTION (parfor)
    % ========================================
    if exist('parallel_enabled', 'var') && parallel_enabled
        fprintf('  Using parallel execution (parfor)\\n\\n');

        % Pre-allocate chunk-local arrays for parfor slicing
        sca_chunk = zeros(n_chunk, n_polarizations);
        ext_chunk = zeros(n_chunk, n_polarizations);
        abs_chunk = zeros(n_chunk, n_polarizations);
        
        % Local copies for parfor
        enei_local = enei;
        chunk_idx_local = chunk_indices;

        parfor i_local = 1:n_chunk
            ien = chunk_idx_local(i_local);

            try
                % Progress (sparse output in parfor)
                if mod(i_local-1, max(1, floor(n_chunk/5))) == 0
                    fprintf('    [Worker] lambda %d/%d (%.1f nm)\\n', ...
                            i_local, n_chunk, enei_local(ien));
                end

                % BEM calculation
                sig = bem \\ exc(p, enei_local(ien));

                % Store results
                sca_chunk(i_local, :) = exc.sca(sig);
                ext_chunk(i_local, :) = exc.ext(sig);
                abs_chunk(i_local, :) = ext_chunk(i_local, :) - sca_chunk(i_local, :);

            catch ME
                fprintf('    [ERROR] lambda %d (%.1f nm): %s\\n', ...
                        ien, enei_local(ien), ME.message);
                sca_chunk(i_local, :) = zeros(1, n_polarizations);
                ext_chunk(i_local, :) = zeros(1, n_polarizations);
                abs_chunk(i_local, :) = zeros(1, n_polarizations);
            end
        end

        % Copy chunk results to main arrays
        sca(chunk_indices, :) = sca_chunk;
        ext(chunk_indices, :) = ext_chunk;
        abs_cross(chunk_indices, :) = abs_chunk;

    else
        % Fallback to serial
        fprintf('  Using serial execution\\n\\n');
        
        for i_local = 1:n_chunk
            ien = chunk_indices(i_local);
            
            if mod(i_local-1, max(1, floor(n_chunk/10))) == 0
                fprintf('    Progress: %d/%d (lambda = %.1f nm)\\n', ...
                        i_local, n_chunk, enei(ien));
            end
            
            try
                sig = bem \\ exc(p, enei(ien));
                sca(ien, :) = exc.sca(sig);
                ext(ien, :) = exc.ext(sig);
                abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            catch ME
                fprintf('    [ERROR] lambda %d (%.1f nm): %s\\n', ...
                        ien, enei(ien), ME.message);
                sca(ien, :) = zeros(1, n_polarizations);
                ext(ien, :) = zeros(1, n_polarizations);
                abs_cross(ien, :) = zeros(1, n_polarizations);
            end
        end
    end
"""
        else:
            # Serial only
            code += """    % ========================================
    % SERIAL EXECUTION
    % ========================================
    fprintf('  Using serial execution\\n\\n');
    
    for i_local = 1:n_chunk
        ien = chunk_indices(i_local);
        
        % Progress
        if mod(i_local-1, max(1, floor(n_chunk/10))) == 0
            fprintf('    Progress: %d/%d (lambda = %.1f nm)\\n', ...
                    i_local, n_chunk, enei(ien));
        end
        
        try
            % BEM calculation
            sig = bem \\ exc(p, enei(ien));
            
            % Store results
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            fprintf('    [ERROR] lambda %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
    end
"""
        
        # Chunk timing
        code += """    
    chunk_time = toc(chunk_start);
    fprintf('\\n  [OK] Chunk %d completed in %.1f seconds (%.1f min)\\n', ...
            ichunk, chunk_time, chunk_time/60);
    fprintf('  Average: %.2f sec/wavelength\\n', chunk_time/n_chunk);
    
    % Brief pause for garbage collection
    pause(0.5);
end

% Total timing for cross sections
total_time = toc(total_start);
calculation_time = total_time;
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('ALL CHUNKS COMPLETED\\n');
fprintf('Total time: %.1f seconds (%.1f minutes)\\n', total_time, total_time/60);
fprintf('Average: %.2f seconds/wavelength\\n', total_time/n_wavelengths);
fprintf('================================================================\\n');
"""

        # ================================================================
        # FIELD CALCULATION - OPTION 1: UNIVERSAL REFERENCE
        # ================================================================
        if calculate_fields:
            code += """
%% ========================================
%% FIELD CALCULATION - OPTION 1: UNIVERSAL REFERENCE
%% ========================================
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('    Field Calculation (Universal Reference Method)             \\n');
fprintf('================================================================\\n');
fprintf('Enhancement uses incoming field in external medium as reference\\n');
fprintf('This shows field enhancement relative to "no particle" baseline\\n');
fprintf('================================================================\\n');
"""
            
            # Determine peak wavelength(s)
            field_wl_idx = self.config.get('field_wavelength_idx', 'middle')

            if field_wl_idx == 'middle':
                code += """
% Use middle wavelength (single wavelength for all polarizations)
field_wavelength_idx = round(n_wavelengths / 2);
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
fprintf('Using middle wavelength: lambda = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif field_wl_idx == 'peak':
                code += """
% Find absorption peak wavelength for EACH polarization
fprintf('Finding absorption peak for each polarization...\\n');

% Find max absorption wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_abs_pol, idx] = max(abs_cross(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('  Pol %d: Peak absorption %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_abs_pol, enei(idx), idx);
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
            elif field_wl_idx == 'peak_ext':
                code += """
% Find extinction peak wavelength for EACH polarization
fprintf('Finding extinction peak for each polarization...\\n');

% Find max extinction wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_ext_pol, idx] = max(ext(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('  Pol %d: Peak extinction %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_ext_pol, enei(idx), idx);
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
            elif field_wl_idx == 'peak_sca':
                code += """
% Find scattering peak wavelength for EACH polarization
fprintf('Finding scattering peak for each polarization...\\n');

% Find max scattering wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_sca_pol, idx] = max(sca(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('  Pol %d: Peak scattering %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_sca_pol, enei(idx), idx);
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
            elif isinstance(field_wl_idx, int):
                code += f"""
% Use specified wavelength index (single wavelength for all polarizations)
field_wavelength_idx = {field_wl_idx};
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
fprintf('Using specified wavelength: lambda = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif isinstance(field_wl_idx, list):
                # List of wavelength values (nm) - map to nearest indices
                wl_list_str = ', '.join([str(wl) for wl in field_wl_idx])
                code += f"""
% Use specified wavelength list (nm) - map to nearest indices
target_wavelengths = [{wl_list_str}];  % Target wavelengths in nm
fprintf('Mapping %d target wavelengths to nearest indices...\\n', length(target_wavelengths));

% Map each target wavelength to nearest index in enei
temp_indices = zeros(1, length(target_wavelengths));
for iwl = 1:length(target_wavelengths)
    [~, nearest_idx] = min(abs(enei - target_wavelengths(iwl)));
    temp_indices(iwl) = nearest_idx;
    fprintf('  Target %.1f nm -> index %d (actual %.1f nm)\\n', ...
            target_wavelengths(iwl), nearest_idx, enei(nearest_idx));
end

% Remove duplicates and sort
unique_field_wavelength_indices = unique(temp_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

% For wavelength list mode: don't use per-polarization mapping
% All wavelengths will calculate all polarizations
field_wavelength_indices = [];  % Empty - will trigger "calculate all polarizations" mode
fprintf('-> %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
            else:
                code += """
% Default: use middle wavelength (single wavelength for all polarizations)
field_wavelength_idx = round(n_wavelengths / 2);
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
fprintf('Using middle wavelength: lambda = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            
            # Create field grid
            use_substrate = self.config.get('use_substrate', False)
            
            if not use_substrate:
                field_region = self.config.get('field_region', {})
                x_range = field_region.get('x_range', [-50, 50, 101])
                y_range = field_region.get('y_range', [0, 0, 1])
                z_range = field_region.get('z_range', [0, 0, 1])
                
                code += """
% Create field grid
fprintf('\\nCreating field grid...\\n');
"""
                
                if y_range[2] == 1:  # xz-plane
                    code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
                elif z_range[2] == 1:  # xy-plane
                    code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
            else:
                code += """
% Substrate mode: grid already created
x_grid = reshape(x_grid, grid_shape);
y_grid = reshape(y_grid, grid_shape);
z_grid = reshape(z_grid, grid_shape);
"""
            
            # External + Internal field setup
            mindist_external = self.config.get('field_mindist', 0.2 if not use_substrate else 0.5)
            mindist_internal = self.config.get('field_mindist_internal', 0.0)
            nmax = self.config.get('field_nmax', 2000)
            
            code += f"""
% Store grid shape
grid_shape = size(x_grid);
n_grid_points = numel(x_grid);

%% Mirror symmetry: Expand to full particle for field calculation
if use_mirror
    fprintf('\\nExpanding mirror particle to full size for field calculation...\\n');
    p_field = full(p);
    fprintf('  [OK] Full particle: %d boundary elements\\n', p_field.n);

    % Create field options without mirror symmetry (since we use full particle)
    op_field = op;
    op_field.sym = [];
    fprintf('  [OK] Field options: mirror symmetry disabled for full particle\\n');
else
    p_field = p;
    op_field = op;
end

%% ========================================
%% STEP 1: External Field Setup (meshfield)
%% ========================================
fprintf('\\n[1/2] Setting up EXTERNAL field calculation...\\n');
field_mindist_external = {mindist_external};
emesh_external = meshfield(p_field, x_grid, y_grid, z_grid, op_field, ...
                           'mindist', field_mindist_external, 'nmax', {nmax});
fprintf('  → External meshfield: %d points\\n', emesh_external.pt.n);

%% ========================================
%% STEP 2: Internal Field Setup (compoint + greenfunction)
%% ========================================
fprintf('\\n[2/2] Setting up INTERNAL field calculation...\\n');

% Auto-detect internal medium index
if size(inout, 1) == 1
    internal_medium_idx = inout(1, 1);
    fprintf('  → Single particle: medium %d\\n', internal_medium_idx);
else
    internal_medium_idx = inout(1, 1);
    fprintf('  → Multi-particle: medium %d (first particle interior)\\n', internal_medium_idx);
end

fprintf('  Creating compoint (medium=%d, mindist={mindist_internal})...\\n', internal_medium_idx);

try
    % FIX 1: compoint returns point object directly (not .pc)
    pt_internal = compoint(p_field, [x_grid(:), y_grid(:), z_grid(:)], op_field, ...
                           'medium', internal_medium_idx, ...
                           'mindist', {mindist_internal});

    fprintf('  Creating Green function...\\n');
    g_internal = greenfunction(pt_internal, p_field, op_field);
    
    % FIX 1: Use pt_internal.n (not pt_internal.pc.n)
    fprintf('  → Internal field setup: %d points\\n', pt_internal.n);
    has_internal_field = true;
    
catch ME
    fprintf('  [!] Internal field setup failed: %s\\n', ME.message);
    fprintf('  [!] Proceeding with EXTERNAL field only\\n');
    has_internal_field = false;
end

fprintf('\\n[OK] Field calculation setup complete\\n');
fprintf('  Grid: %dx%d = %d points\\n', grid_shape(1), grid_shape(2), n_grid_points);
if has_internal_field
    fprintf('  External: %d points, Internal: %d points\\n', ...
            emesh_external.pt.n, pt_internal.n);
else
    fprintf('  External: %d points (Internal: disabled)\\n', emesh_external.pt.n);
end

%% ========================================
%% STEP 3-4: Calculate Fields for Each Wavelength and Polarization
%% ========================================
field_data = struct();
surface_charge = struct();  % Initialize surface charge storage
field_data_idx = 0;
field_calc_start = tic;

fprintf('\\n================================================================\\n');
fprintf('  Processing %d wavelength(s) x %d polarization(s) = %d field calculations\\n', ...
        n_field_wavelengths, n_polarizations, n_field_wavelengths * n_polarizations);
fprintf('================================================================\\n');

for iwl = 1:n_field_wavelengths
    field_wavelength_idx = unique_field_wavelength_indices(iwl);
    fprintf('\\n[%d/%d] Wavelength: lambda = %.1f nm (index %d)\\n', ...
            iwl, n_field_wavelengths, enei(field_wavelength_idx), field_wavelength_idx);

    % Find which polarizations to calculate at this wavelength
    % If using wavelength list or empty result, calculate ALL polarizations
    pols_at_this_wl = find(field_wavelength_indices == field_wavelength_idx);
    if isempty(pols_at_this_wl)
        % No peak match - this happens with wavelength list mode
        % Calculate all polarizations at this wavelength
        pols_at_this_wl = 1:n_polarizations;
        fprintf('  Calculating ALL polarizations: [%s]\\n', num2str(pols_at_this_wl));
    else
        fprintf('  Polarizations with peak at this wavelength: [%s]\\n', num2str(pols_at_this_wl));
    end

    % Clear BEM and recalculate for this wavelength
    % Reinitialize BEM solver (works for both mirror and non-mirror)
    bem = bemsolver(p, op);
    sig_peak = bem \\ exc(p, enei(field_wavelength_idx));
    fprintf('  [OK] BEM solution ready\\n');

    % Mirror symmetry: expand surface charges to full particle
    if use_mirror
        fprintf('  Expanding surface charges to full particle...\\n');
        sig_field = full(sig_peak);
    else
        sig_field = sig_peak;
    end

for ipol = pols_at_this_wl
    field_data_idx = field_data_idx + 1;
    fprintf('\\n  Processing polarization %d (field_data index: %d)...\\n', ipol, field_data_idx);
    
"""
            
            # Create single-polarization excitation
            excitation_type = self.config['excitation_type']
            
            if excitation_type == 'planewave':
                code += """    % Create single-polarization plane wave
    exc_single = planewave(pol(ipol, :), dir(ipol, :), op);
"""
            elif excitation_type == 'dipole':
                code += """    % Create dipole excitation
    pt_single = compoint(p, dip_pos, op);
    exc_single = dipole(pt_single, dip_mom, op);
"""
            else:
                code += """    % Use original excitation
    exc_single = exc;
"""
            
            # FIXED: Complete 3D/4D array handling
            code += """
    %% EXTERNAL FIELD
    fprintf('    → External field...\\n');

    % Induced field from BEM solution (use sig_field for mirror symmetry)
    e_induced_ext_all = emesh_external(sig_field);

    % Track whether field is grid-based (4D) or point-based (2D)
    ext_is_grid_based = (ndims(e_induced_ext_all) == 4);
    fprintf('      Raw external field size: [%s]\\n', num2str(size(e_induced_ext_all)));
    fprintf('      Grid-based: %d\\n', ext_is_grid_based);

    if ext_is_grid_based
        % 4D array: [ny, nx, 3, n_pol] - KEEP GRID STRUCTURE
        % This preserves spatial ordering for correct grid assignment
        e_induced_ext_grid = e_induced_ext_all(:, :, :, ipol);  % [ny, nx, 3]
        fprintf('      Extracted grid shape: [%s]\\n', num2str(size(e_induced_ext_grid)));

    elseif ndims(e_induced_ext_all) == 3
        % 3D array: Two cases
        if size(e_induced_ext_all, 3) == n_polarizations
            % [n_points, 3, n_pol] → point-based
            e_induced_ext = e_induced_ext_all(:, :, ipol);
        else
            % [ny, nx, 3] → grid-based single polarization
            e_induced_ext_grid = e_induced_ext_all;
            ext_is_grid_based = true;
        end
    else
        % 2D array: [n_points, 3] - point-based
        e_induced_ext = e_induced_ext_all;
    end

    % Incoming field
    exc_field_ext = exc_single.field(emesh_external.pt, enei(field_wavelength_idx));
    e_incoming_ext_all = emesh_external(exc_field_ext);

    fprintf('      Raw incoming field size: [%s]\\n', num2str(size(e_incoming_ext_all)));

    if ext_is_grid_based
        % 4D/3D grid-based: keep grid structure
        if ndims(e_incoming_ext_all) == 4
            e_incoming_ext_grid = e_incoming_ext_all(:, :, :, ipol);
        else
            e_incoming_ext_grid = e_incoming_ext_all;
        end

        % Calculate total field in grid form
        e_total_ext_grid_3d = e_induced_ext_grid + e_incoming_ext_grid;  % [ny, nx, 3]
        fprintf('      Total external grid shape: [%s]\\n', num2str(size(e_total_ext_grid_3d)));

    else
        % Point-based: extract for polarization
        if ndims(e_incoming_ext_all) == 3 && size(e_incoming_ext_all, 3) == n_polarizations
            e_incoming_ext = e_incoming_ext_all(:, :, ipol);
        else
            e_incoming_ext = e_incoming_ext_all;
        end

        % Ensure 2D: [n_points, 3]
        if ndims(e_induced_ext) == 3
            e_induced_ext = squeeze(e_induced_ext);
        end
        if ndims(e_incoming_ext) == 3
            e_incoming_ext = squeeze(e_incoming_ext);
        end

        % Verify sizes match
        if size(e_induced_ext, 1) ~= size(e_incoming_ext, 1)
            error('Size mismatch: induced [%d, 3] vs incoming [%d, 3]', ...
                  size(e_induced_ext, 1), size(e_incoming_ext, 1));
        end

        % Total external field (point-based)
        e_total_ext = e_induced_ext + e_incoming_ext;
        fprintf('      Total external points: [%s]\\n', num2str(size(e_total_ext)));
    end
    
    %% INTERNAL FIELD
    if has_internal_field
        fprintf('    → Internal field...\\n');
        
        % Induced field using Green function (use sig_field for mirror symmetry)
        f_induced_int = field(g_internal, sig_field);
        e_induced_int_all = f_induced_int.e;
        
        fprintf('      Raw internal induced field size: [%s]\\n', num2str(size(e_induced_int_all)));
        
        % FIX 3: Complete 3D/4D handling for internal fields
        if ndims(e_induced_int_all) == 4
            % 4D: [nz, nx, 3, n_pol]
            e_induced_int = e_induced_int_all(:, :, :, ipol);
            e_induced_int = reshape(e_induced_int, [], 3);
            
            % Remove NaN points
            valid_mask = all(isfinite(e_induced_int), 2);
            e_induced_int = e_induced_int(valid_mask, :);
            
        elseif ndims(e_induced_int_all) == 3
            % 3D: Check if polarization dimension exists
            if size(e_induced_int_all, 3) == n_polarizations
                % [n_points, 3, n_pol] → slice for this polarization
                e_induced_int = e_induced_int_all(:, :, ipol);
                fprintf('      Sliced 3D array: [%s]\\n', num2str(size(e_induced_int)));
            else
                % [n_points, 3] → keep as is
                e_induced_int = e_induced_int_all;
            end
        else
            % 2D: [n_points, 3]
            e_induced_int = e_induced_int_all;
        end
        
        % Incoming field at internal points (will be used for total field, NOT enhancement!)
        exc_field_int = exc_single.field(pt_internal, enei(field_wavelength_idx));
        e_incoming_int_all = exc_field_int.e;
        
        fprintf('      Raw internal incoming field size: [%s]\\n', num2str(size(e_incoming_int_all)));
        
        % Extract for this polarization
        if ndims(e_incoming_int_all) == 4
            % 4D: [nz, nx, 3, n_pol]
            e_incoming_int = e_incoming_int_all(:, :, :, ipol);
            e_incoming_int = reshape(e_incoming_int, [], 3);
            
            % Remove NaN points
            valid_mask = all(isfinite(e_incoming_int), 2);
            e_incoming_int = e_incoming_int(valid_mask, :);
            
        elseif ndims(e_incoming_int_all) == 3
            % 3D: Check if polarization dimension exists
            if size(e_incoming_int_all, 3) == n_polarizations
                % [n_points, 3, n_pol] → slice for this polarization
                e_incoming_int = e_incoming_int_all(:, :, ipol);
                fprintf('      Sliced 3D array: [%s]\\n', num2str(size(e_incoming_int)));
            else
                % [n_points, 3] → keep as is
                e_incoming_int = e_incoming_int_all;
            end
        else
            % 2D: [n_points, 3]
            e_incoming_int = e_incoming_int_all;
        end
        
        % Ensure 2D
        if ndims(e_induced_int) == 3
            e_induced_int = squeeze(e_induced_int);
        end
        if ndims(e_incoming_int) == 3
            e_incoming_int = squeeze(e_incoming_int);
        end
        
        % Verify sizes
        fprintf('      After processing: induced [%s], incoming [%s]\\n', ...
                num2str(size(e_induced_int)), num2str(size(e_incoming_int)));
        
        if size(e_induced_int, 1) ~= size(e_incoming_int, 1) || size(e_induced_int, 2) ~= 3
            error('Size mismatch: internal induced [%s] vs incoming [%s]', ...
                  num2str(size(e_induced_int)), num2str(size(e_incoming_int)));
        end
        
        % Total internal field
        e_total_int = e_induced_int + e_incoming_int;
        
        fprintf('      Final internal field size: [%s]\\n', num2str(size(e_total_int)));
    else
        e_total_int = [];
    end
    
    %% MERGE EXTERNAL + INTERNAL
    fprintf('    → Merging fields...\\n');

    % Initialize full grid with NaN
    e_total_full = nan(n_grid_points, 3);

    % Separate storage for visualization
    e_total_ext_grid = nan(n_grid_points, 3);
    e_total_int_grid = nan(n_grid_points, 3);

    % Flatten grid coordinates
    x_flat = x_grid(:);
    y_flat = y_grid(:);
    z_flat = z_grid(:);

    % Extract unique grid vectors for proper indexing
    x_vec = unique(x_grid);
    y_vec = unique(y_grid);
    z_vec = unique(z_grid);

    % Fill external points - use different methods for grid-based vs point-based
    if ext_is_grid_based
        % GRID-BASED: Direct assignment from grid structure (preserves spatial ordering)
        fprintf('      Using grid-based assignment (4D array)...\\n');

        % Reshape 3D grid [ny, nx, 3] to flat [n_grid, 3]
        e_total_ext_flat = reshape(e_total_ext_grid_3d, [], 3);  % [n_grid, 3]

        % Copy to output arrays (NaN values stay where they are)
        e_total_full = e_total_ext_flat;
        e_total_ext_grid = e_total_ext_flat;

        n_valid_ext = sum(all(isfinite(e_total_ext_flat), 2));
        fprintf('      Filled %d/%d external points from grid\\n', n_valid_ext, n_grid_points);

    else
        % POINT-BASED: Map using emesh_external.pt coordinates
        fprintf('      Using point-based mapping (%d points)...\\n', emesh_external.pt.n);

        % Determine plane type and create proper index mapping
        if numel(unique(y_grid)) == 1
            % xz-plane: y is constant
            fprintf('      Grid type: xz-plane\\n');
            for ii = 1:emesh_external.pt.n
                [~, ix] = min(abs(emesh_external.pt.pos(ii,1) - x_vec));
                [~, iz] = min(abs(emesh_external.pt.pos(ii,3) - z_vec));
                idx = sub2ind(grid_shape, iz, ix);
                e_total_full(idx, :) = e_total_ext(ii, :);
                e_total_ext_grid(idx, :) = e_total_ext(ii, :);
            end
        elseif numel(unique(z_grid)) == 1
            % xy-plane: z is constant
            fprintf('      Grid type: xy-plane\\n');
            for ii = 1:emesh_external.pt.n
                [~, ix] = min(abs(emesh_external.pt.pos(ii,1) - x_vec));
                [~, iy] = min(abs(emesh_external.pt.pos(ii,2) - y_vec));
                idx = sub2ind(grid_shape, iy, ix);
                e_total_full(idx, :) = e_total_ext(ii, :);
                e_total_ext_grid(idx, :) = e_total_ext(ii, :);
            end
        else
            % 3D: fallback to Manhattan distance
            fprintf('      Grid type: 3D (using Manhattan distance)\\n');
            for ii = 1:emesh_external.pt.n
                dx = abs(x_flat - emesh_external.pt.pos(ii,1));
                dy = abs(y_flat - emesh_external.pt.pos(ii,2));
                dz = abs(z_flat - emesh_external.pt.pos(ii,3));
                [~, idx] = min(dx + dy + dz);
                e_total_full(idx, :) = e_total_ext(ii, :);
                e_total_ext_grid(idx, :) = e_total_ext(ii, :);
            end
        end
    end
    
    % Fill internal points (IMPROVED: Exact grid matching)
    if has_internal_field
        fprintf('      Filling %d internal points (exact matching)...\\n', pt_internal.n);
        
        % Extract grid vectors
        if numel(unique(y_grid)) == 1
            % xz-plane: y is constant
            x_vec = unique(x_grid);
            z_vec = unique(z_grid);
            
            fprintf('      Grid type: xz-plane (y=%.1f)\\n', unique(y_grid));
            fprintf('      x range: [%.1f, %.1f], %d points\\n', min(x_vec), max(x_vec), numel(x_vec));
            fprintf('      z range: [%.1f, %.1f], %d points\\n', min(z_vec), max(z_vec), numel(z_vec));
            
            % Find nearest indices for each internal point
            ix = zeros(pt_internal.n, 1);
            iz = zeros(pt_internal.n, 1);
            
            for ii = 1:pt_internal.n
                [~, ix(ii)] = min(abs(pt_internal.pos(ii,1) - x_vec));
                [~, iz(ii)] = min(abs(pt_internal.pos(ii,3) - z_vec));
            end
            
            % Convert to linear index
            linear_idx = sub2ind(grid_shape, iz, ix);
            
        elseif numel(unique(z_grid)) == 1
            % xy-plane: z is constant
            x_vec = unique(x_grid);
            y_vec = unique(y_grid);
            
            fprintf('      Grid type: xy-plane (z=%.1f)\\n', unique(z_grid));
            fprintf('      x range: [%.1f, %.1f], %d points\\n', min(x_vec), max(x_vec), numel(x_vec));
            fprintf('      y range: [%.1f, %.1f], %d points\\n', min(y_vec), max(y_vec), numel(y_vec));
            
            % Find nearest indices
            ix = zeros(pt_internal.n, 1);
            iy = zeros(pt_internal.n, 1);
            
            for ii = 1:pt_internal.n
                [~, ix(ii)] = min(abs(pt_internal.pos(ii,1) - x_vec));
                [~, iy(ii)] = min(abs(pt_internal.pos(ii,2) - y_vec));
            end
            
            % Convert to linear index
            linear_idx = sub2ind(grid_shape, iy, ix);
        else
            error('Unsupported grid configuration');
        end
        
        % Check for duplicates
        [unique_idx, ~, ic] = unique(linear_idx);
        n_unique = numel(unique_idx);
        n_duplicates = pt_internal.n - n_unique;
        
        if n_duplicates > 0
            fprintf('      Warning: %d duplicate grid points detected\\n', n_duplicates);
            fprintf('      Multiple internal points map to same grid location\\n');
        end
        
        % Assign internal field to exact grid locations
        e_total_full(linear_idx, :) = e_total_int;
        
        % Store internal separately
        e_total_int_grid(linear_idx, :) = e_total_int;
        
        fprintf('      Internal field mapped to %d unique grid points\\n', n_unique);
    end
    
    % Count filled points
    n_filled = sum(all(isfinite(e_total_full), 2));
    n_ext_only = sum(all(isfinite(e_total_ext_grid), 2) & all(isnan(e_total_int_grid), 2));
    n_int_only = sum(all(isfinite(e_total_int_grid), 2) & all(isnan(e_total_ext_grid), 2));
    n_overlap = sum(all(isfinite(e_total_ext_grid), 2) & all(isfinite(e_total_int_grid), 2));
    
    fprintf('      Merge complete: %d total points filled\\n', n_filled);
    fprintf('        External only: %d points\\n', n_ext_only);
    fprintf('        Internal only: %d points\\n', n_int_only);
    fprintf('        Overlap: %d points\\n', n_overlap);
    
    %% OPTION 1: UNIVERSAL REFERENCE ENHANCEMENT CALCULATION
    fprintf('    → Calculating enhancement (universal reference)...\\n');
    
    % CRITICAL FIX: Determine correct external (embedding) medium index
    % inout format: [internal_medium_idx, external_medium_idx]
    if size(inout, 1) == 1
        % Single particle
        external_medium_idx = inout(1, 2);  % Column 2 = external/embedding medium
    else
        % Multi-particle: use first particle's external medium
        external_medium_idx = inout(1, 2);
    end
    
    fprintf('      Auto-detected external medium index: %d\\n', external_medium_idx);
    fprintf('      (Internal medium: %d, External medium: %d)\\n', ...
            inout(1,1), external_medium_idx);
    """
            
            # Check if substrate exists
            if use_substrate:
                code += """    if exist('layer', 'var')
        external_medium_idx = layer.ind(1);  % Override: Upper layer medium
        fprintf('      Substrate detected: using layer medium %d\\n', external_medium_idx);
    end
    """
            
            code += """
    % CRITICAL FIX: Calculate incoming field DIRECTLY (avoid compoint issues)
    % For plane wave: E0 = pol * exp(i*k·r)
    fprintf('      Computing incoming field reference (direct calculation)...\\n');
    
    % Get wave vector
    k0 = 2 * pi / enei(field_wavelength_idx);  % Free space wave number
    kvec = k0 * dir(ipol, :);                 % Wave vector: k = k0 * direction
    pol_vec = pol(ipol, :);                   % Polarization vector
    
    % Calculate phase at each grid point: exp(i*k·r)
    phase = exp(1i * (kvec(1)*x_flat + kvec(2)*y_flat + kvec(3)*z_flat));
    
    % Incoming field: E0 = pol * phase (for ALL grid points)
    e_incoming_reference = zeros(n_grid_points, 3);
    e_incoming_reference(:, 1) = pol_vec(1) * phase;
    e_incoming_reference(:, 2) = pol_vec(2) * phase;
    e_incoming_reference(:, 3) = pol_vec(3) * phase;
    
    % Calculate reference intensity (universal for all points)
    e0_reference_intensity = sum(e_incoming_reference .* conj(e_incoming_reference), 2);
    
    fprintf('      Reference incoming intensity stats:\\n');
    fprintf('        min: %.3e, max: %.3e, valid: %d/%d\\n', ...
            min(abs(e0_reference_intensity)), max(abs(e0_reference_intensity)), ...
            sum(isfinite(e0_reference_intensity)), numel(e0_reference_intensity));
    
    % Sanity check
    if all(abs(e0_reference_intensity) < 1e-12)
        error('Universal reference incoming field is all zero! Check calculation.');
    end
    
    % Calculate field intensities
    e_intensity = sum(e_total_full .* conj(e_total_full), 2);
    e_intensity_ext = sum(e_total_ext_grid .* conj(e_total_ext_grid), 2);
    e_intensity_int = sum(e_total_int_grid .* conj(e_total_int_grid), 2);
    
    % Apply threshold and calculate intensity enhancement
    e0_threshold = 1e-10;
    
    % Merged (visualization)
    intensity_enhancement = e_intensity ./ max(e0_reference_intensity, e0_threshold);
    intensity_enhancement(e0_reference_intensity < e0_threshold | isnan(e_intensity)) = NaN;
    
    % External enhancement (using universal reference)
    intensity_enhancement_ext = e_intensity_ext ./ max(e0_reference_intensity, e0_threshold);
    intensity_enhancement_ext(e0_reference_intensity < e0_threshold | isnan(e_intensity_ext)) = NaN;
    
    % Internal enhancement (using universal reference) ← CRITICAL FIX!
    intensity_enhancement_int = e_intensity_int ./ max(e0_reference_intensity, e0_threshold);
    intensity_enhancement_int(e0_reference_intensity < e0_threshold | isnan(e_intensity_int)) = NaN;
    
    % Calculate field enhancement: |E/E0| = sqrt(|E|²/|E0|²)
    field_enhancement = sqrt(intensity_enhancement);
    field_enhancement_ext = sqrt(intensity_enhancement_ext);
    field_enhancement_int = sqrt(intensity_enhancement_int);

    % Reshape to grid
    intensity_enhancement = reshape(intensity_enhancement, grid_shape);
    intensity_enhancement_ext = reshape(intensity_enhancement_ext, grid_shape);
    intensity_enhancement_int = reshape(intensity_enhancement_int, grid_shape);
    field_enhancement = reshape(field_enhancement, grid_shape);
    field_enhancement_ext = reshape(field_enhancement_ext, grid_shape);
    field_enhancement_int = reshape(field_enhancement_int, grid_shape);
    e_total_grid = reshape(e_total_full, [grid_shape, 3]);
    e_total_ext_grid = reshape(e_total_ext_grid, [grid_shape, 3]);
    e_total_int_grid = reshape(e_total_int_grid, [grid_shape, 3]);

    % Reshape raw intensities for energy ratio calculation: sum(|E|²)/sum(|E0|²)
    e_sq = reshape(e_intensity, grid_shape);              % |E|² (merged)
    e_sq_ext = reshape(e_intensity_ext, grid_shape);      % |E|² (external)
    e_sq_int = reshape(e_intensity_int, grid_shape);      % |E|² (internal)
    e0_sq = reshape(e0_reference_intensity, grid_shape);  % |E0|² (reference)

    fprintf('      Intensity_enh valid (universal ref - direct calc):\\n');
    fprintf('        Merged: %d/%d\\n', sum(isfinite(intensity_enhancement(:))), numel(intensity_enhancement));
    fprintf('        External: %d/%d\\n', sum(isfinite(intensity_enhancement_ext(:))), numel(intensity_enhancement_ext));
    fprintf('        Internal: %d/%d\\n', sum(isfinite(intensity_enhancement_int(:))), numel(intensity_enhancement_int));
    
    if has_internal_field && sum(isfinite(intensity_enhancement_int(:))) > 0
        fprintf('      [OK] Internal enhancement: min=%.3f, max=%.3f\\n', ...
                min(intensity_enhancement_int(isfinite(intensity_enhancement_int))), ...
                max(intensity_enhancement_int(isfinite(intensity_enhancement_int))));
    elseif has_internal_field
        fprintf('      [WARNING] All internal enhancement = NaN!\\n');
        fprintf('      Possible causes: threshold too high or intensity too low\\n');
    end
    
    %% STORE FIELD DATA
    field_data(field_data_idx).wavelength = enei(field_wavelength_idx);
    field_data(field_data_idx).wavelength_idx = field_wavelength_idx;
    field_data(field_data_idx).polarization = pol(ipol, :);
    field_data(field_data_idx).polarization_idx = ipol;

    % Combined (merged) - field and intensity enhancement
    field_data(field_data_idx).e_total = e_total_grid;
    field_data(field_data_idx).enhancement = field_enhancement;          % |E/E0| (field enhancement)
    field_data(field_data_idx).intensity = intensity_enhancement;        % |E|²/|E0|² (intensity enhancement)
    field_data(field_data_idx).e_sq = e_sq;                              % |E|² (raw intensity for energy ratio)
    field_data(field_data_idx).e0_sq = e0_sq;                            % |E0|² (reference intensity for energy ratio)

    % Separate fields
    field_data(field_data_idx).e_total_ext = e_total_ext_grid;
    field_data(field_data_idx).e_total_int = e_total_int_grid;
    field_data(field_data_idx).enhancement_ext = field_enhancement_ext;      % |E/E0| (field enhancement)
    field_data(field_data_idx).enhancement_int = field_enhancement_int;      % |E/E0| (field enhancement)
    field_data(field_data_idx).intensity_ext = intensity_enhancement_ext;    % |E|²/|E0|² (intensity enhancement)
    field_data(field_data_idx).intensity_int = intensity_enhancement_int;    % |E|²/|E0|² (intensity enhancement)
    field_data(field_data_idx).e_sq_ext = e_sq_ext;                          % |E|² external (raw)
    field_data(field_data_idx).e_sq_int = e_sq_int;                          % |E|² internal (raw)

    % Grid coordinates
    field_data(field_data_idx).x_grid = x_grid;
    field_data(field_data_idx).y_grid = y_grid;
    field_data(field_data_idx).z_grid = z_grid;

    fprintf('    → Stored field_data(%d) [UNIVERSAL REFERENCE METHOD]\\n', field_data_idx);
    fprintf('      Wavelength: %.1f nm, Polarization: %d\\n', enei(field_wavelength_idx), ipol);
    fprintf('      Valid points (merged): %d/%d\\n', sum(isfinite(intensity_enhancement(:))), numel(intensity_enhancement));
    fprintf('      Valid points (external): %d/%d\\n', sum(isfinite(intensity_enhancement_ext(:))), numel(intensity_enhancement_ext));
    fprintf('      Valid points (internal): %d/%d\\n', sum(isfinite(intensity_enhancement_int(:))), numel(intensity_enhancement_int));

    %% SAVE SURFACE CHARGE (for plasmon mode analysis)
    % Extract surface charge from BEM solution (use sig_field for mirror symmetry)
    charge_values_all = [];
    extraction_method = '';

    % Method 1: Check if it's already numeric
    if isnumeric(sig_field)
        charge_values_all = sig_field;
        extraction_method = 'numeric';

    % Method 2: Try .sig1 field (MNPBEM compstruct object - particle 1)
    elseif (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'sig1') || isprop(sig_field, 'sig1'))
        try
            charge_values_all = sig_field.sig1;
            extraction_method = '.sig1 (compstruct)';
        catch
        end

    % Method 3: Try .sig2 field (MNPBEM compstruct object - particle 2)
    elseif isempty(charge_values_all) && (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'sig2') || isprop(sig_field, 'sig2'))
        try
            charge_values_all = sig_field.sig2;
            extraction_method = '.sig2 (compstruct)';
        catch
        end

    % Method 4: Try .sig field (older MNPBEM bemsolve object)
    elseif (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'sig') || isprop(sig_field, 'sig'))
        try
            charge_values_all = sig_field.sig;
            extraction_method = '.sig';
        catch
        end

    % Method 5: Try .val field (alternative MNPBEM format)
    elseif (isobject(sig_field) || isstruct(sig_field)) && (isfield(sig_field, 'val') || isprop(sig_field, 'val'))
        try
            charge_values_all = sig_field.val;
            extraction_method = '.val';
        catch
        end

    % Method 6: Try full() for sparse matrices
    elseif issparse(sig_field)
        try
            charge_values_all = full(sig_field);
            extraction_method = 'full()';
        catch
        end

    % Method 7: Try double() conversion
    else
        try
            charge_values_all = double(sig_field);
            extraction_method = 'double()';
        catch
        end
    end

    % Method 8: Try subsref (:) if still empty
    if isempty(charge_values_all)
        try
            charge_values_all = sig_field(:);
            if isnumeric(charge_values_all) && ~isempty(charge_values_all)
                extraction_method = 'subsref(:)';
            else
                charge_values_all = [];
            end
        catch
        end
    end

    % Log extraction result
    if ~isempty(charge_values_all)
        fprintf('    → Surface charge extracted via %s: size [%s]\\n', extraction_method, num2str(size(charge_values_all)));
    else
        fprintf('    [WARNING] Could not extract surface charge from sig_field\\n');
        fprintf('    [DEBUG] class=%s, size=[%s], isobj=%d, struct=%d, numeric=%d, sparse=%d\\n', ...
                class(sig_field), num2str(size(sig_field)), ...
                isobject(sig_field), isstruct(sig_field), isnumeric(sig_field), issparse(sig_field));
        if isobject(sig_field) || isstruct(sig_field)
            try
                fn = fieldnames(sig_field);
                fprintf('    [DEBUG] Available fields (%d): %s\\n', length(fn), strjoin(fn(1:min(10,end)), ', '));
            catch
            end
        end
    end

    % Only save if charge extraction succeeded
    if ~isempty(charge_values_all)
        % Select polarization column
        if size(charge_values_all, 2) >= ipol
            charge_values = charge_values_all(:, ipol);
        else
            charge_values = charge_values_all(:, 1);
        end

        % Store surface charge data (same index as field_data for consistency)
        % Use p_field for mirror symmetry (full particle geometry)
        surface_charge(field_data_idx).wavelength = enei(field_wavelength_idx);
        surface_charge(field_data_idx).wavelength_idx = field_wavelength_idx;
        surface_charge(field_data_idx).polarization = pol(ipol, :);
        surface_charge(field_data_idx).polarization_idx = ipol;
        surface_charge(field_data_idx).vertices = p_field.verts;      % Vertex coordinates
        surface_charge(field_data_idx).faces = p_field.faces;         % Face connectivity
        surface_charge(field_data_idx).centroids = p_field.pos;       % Face centers
        surface_charge(field_data_idx).normals = p_field.nvec;        % Face normals
        surface_charge(field_data_idx).areas = p_field.area;          % Face areas
        surface_charge(field_data_idx).charge = charge_values;  % Surface charge values

        fprintf('    → Stored surface_charge(%d): %d faces, %d vertices\\n', ...
                field_data_idx, size(p_field.faces, 1), size(p_field.verts, 1));
    else
        fprintf('    → Surface charge extraction failed, skipping...\\n');
    end

end  % for ipol
end  % for iwl

field_calc_time = toc(field_calc_start);
fprintf('\\n[OK] Field calculation completed in %.1f seconds\\n', field_calc_time);
fprintf('  Total field_data entries: %d\\n', field_data_idx);
fprintf('================================================================\\n');
fprintf('ENHANCEMENT METHOD: Universal Reference (Direct Calculation)\\n');
fprintf('Reference field: Plane wave E0 = pol * exp(i*k·r)\\n');
fprintf('Enhancement: |E/E0| (field enhancement)\\n');
fprintf('Intensity:   |E|²/|E0|² (intensity enhancement)\\n');
fprintf('================================================================\\n');
"""

        return code
